--- src/TerrariaNetCore/Terraria/GameContent/UI/EmoteBubble.cs
+++ src/tModLoader/Terraria/GameContent/UI/EmoteBubble.cs
@@ -4,12 +_,13 @@
 using Microsoft.Xna.Framework.Graphics;
 using Terraria.GameContent.Events;
 using Terraria.ID;
+using Terraria.ModLoader;
 
 namespace Terraria.GameContent.UI;
 
 public class EmoteBubble
 {
-	private static int[] CountNPCs = new int[NPCID.Count];
+	internal static int[] CountNPCs = new int[NPCID.Count];
 	public static Dictionary<int, EmoteBubble> byID = new Dictionary<int, EmoteBubble>();
 	private static List<int> toClean = new List<int>();
 	public static int NextID;
@@ -64,7 +_,23 @@
 			else if (anch.entity is Projectile)
 				item = 2;
 
+			// #WorldUIAnchorProjectileSyncFix: Explanation below
+			// Vanilla never uses Projectile as a WorldUIAnchor, but if mods do, it is very likely to desync.
+			// As whoAmI is not enough to match a projectile between sides, TML rewrites it to use identity + owner instead.
+			// It does so by packing the anchor entity type together with the owner if it's a projectile.
+			// Chosen because both variables can never go above 255 (whoAmI can go above that for projectiles), allowing for easier masking.
+			// Methods (including the IO protocol) accessing this packed owner/type pair handle it properly.
+			// This adds an overhead of a byte to the message 91 (SyncEmoteBubble) in case of Projectile.
+			// tl;dr: byte type -> ushort packedOwnerType [owner << 8 | type] (only if it's a projectile)
+			int whoAmI = anch.entity.whoAmI;
+			if (!ModNet.AllowVanillaClients) {
+				if (anch.entity is Projectile projectile) {
+					whoAmI = projectile.identity; // This is the meta parameter in DeserializeNetAnchor
+					item = projectile.owner << 8 | item;
+				}
+			}
+
-			return Tuple.Create(item, anch.entity.whoAmI);
+			return Tuple.Create(item, whoAmI);
 		}
 
 		return Tuple.Create(0, 0);
@@ -72,12 +_,33 @@
 
 	public static WorldUIAnchor DeserializeNetAnchor(int type, int meta)
 	{
+		// #WorldUIAnchorProjectileSyncFix
+		// Unpack type for the switch case evaluation, use the owner in the Projectile case
+		int packedOwnerType = type;
+		type = packedOwnerType & 0xFF; // Masking has no effect on vanilla value
+
 		switch (type) {
 			case 0:
 				return new WorldUIAnchor(Main.npc[meta]);
 			case 1:
 				return new WorldUIAnchor(Main.player[meta]);
 			case 2:
+				if (!ModNet.AllowVanillaClients) {
+					// meta represents the identity here
+					int owner = packedOwnerType >> 8;
+
+					// identity matching code taken from MessageBuffer.GetData case 27
+					int whoAmI = Main.maxProjectiles;
+					for (int i = 0; i < Main.maxProjectiles; i++) {
+						Projectile projectile = Main.projectile[i];
+						if (projectile.owner == owner && projectile.identity == meta && projectile.active) {
+							whoAmI = i;
+							break;
+						}
+					}
+
+					return new WorldUIAnchor(Main.projectile[whoAmI]);
+				}
 				return new WorldUIAnchor(Main.projectile[meta]);
 			default:
 				throw new Exception("How did you end up getting this?");
@@ -122,7 +_,7 @@
 
 	public static void CheckForNPCsToReactToEmoteBubble(int emoteID, Player player)
 	{
-		for (int i = 0; i < 200; i++) {
+		for (int i = 0; i < Main.maxNPCs; i++) {
 			NPC nPC = Main.npc[i];
 			if (nPC != null && nPC.active && nPC.aiStyle == 7 && nPC.townNPC && !(nPC.ai[0] >= 2f) && ((player.CanBeTalkedTo && player.Distance(nPC.Center) < 200f) || !Collision.CanHitLine(nPC.Top, 0, 0, player.Top, 0, 0))) {
 				int direction = (nPC.position.X < player.position.X).ToDirectionInt();
@@ -238,7 +_,7 @@
 		Player plr = Main.player[Player.FindClosest(((NPC)anchor.entity).Center, 0, 0)];
 		List<int> list = new List<int>();
 		bool flag = false;
-		for (int i = 0; i < 200; i++) {
+		for (int i = 0; i < Main.maxNPCs; i++) {
 			if (Main.npc[i].active && Main.npc[i].boss)
 				flag = true;
 		}
@@ -369,17 +_,17 @@
 
 	private void ProbeTownNPCs(List<int> list)
 	{
-		for (int i = 0; i < NPCID.Count; i++) {
+		for (int i = 0; i < NPCLoader.NPCCount; i++) {
 			CountNPCs[i] = 0;
 		}
 
-		for (int j = 0; j < 200; j++) {
+		for (int j = 0; j < Main.maxNPCs; j++) {
 			if (Main.npc[j].active)
 				CountNPCs[Main.npc[j].type]++;
 		}
 
 		int type = ((NPC)anchor.entity).type;
-		for (int k = 0; k < NPCID.Count; k++) {
+		for (int k = 0; k < NPCLoader.NPCCount; k++) {
 			if (NPCID.Sets.FaceEmote[k] > 0 && CountNPCs[k] > 0 && k != type)
 				list.Add(NPCID.Sets.FaceEmote[k]);
 		}
