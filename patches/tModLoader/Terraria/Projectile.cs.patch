--- src/TerrariaNetCore/Terraria/Projectile.cs
+++ src/tModLoader/Terraria/Projectile.cs
@@ -20,12 +_,14 @@
 using Terraria.ID;
 using Terraria.Localization;
 using Terraria.Physics;
+using Terraria.ModLoader;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using LegacySoundStyle = Terraria.Audio.SoundStyle;
 
 namespace Terraria
 {
-	public class Projectile : Entity
+	public partial class Projectile : Entity
 	{
 		private class NPCDistanceByIndexComparator : IComparer<Tuple<int, float>>
 		{
@@ -88,7 +_,7 @@
 		public float knockBack;
 		public bool friendly;
 		public int penetrate = 1;
-		private int[] localNPCImmunity = new int[200];
+		public int[] localNPCImmunity = new int[Main.maxNPCs];
 		public bool usesLocalNPCImmunity;
 		public bool usesIDStaticNPCImmunity;
 		public int maxPenetrate = 1;
@@ -97,10 +_,18 @@
 		public bool netUpdate;
 		public bool netUpdate2;
 		public int netSpam;
+		/// <summary>
+		/// Holds the value of <see cref="Entity.position"/> from previous updates from newest to oldest. Use for drawing trails. Must be used with <see cref="ProjectileID.Sets.TrailCacheLength"/> and <see cref="ProjectileID.Sets.TrailingMode"/> to be used properly.
+		/// </summary>
 		public Vector2[] oldPos = new Vector2[10];
+		/// <summary>
+		/// Holds the value of <see cref="Projectile.rotation"/> from previous updates from newest to oldest. Use for drawing trails. Must be used with <see cref="ProjectileID.Sets.TrailCacheLength"/> and <see cref="ProjectileID.Sets.TrailingMode"/> to be used properly.
+		/// </summary>
 		public float[] oldRot = new float[10];
+		/// <summary>
+		/// Holds the value of <see cref="Projectile.spriteDirection"/> from previous updates from newest to oldest. Use for drawing trails. Must be used with <see cref="ProjectileID.Sets.TrailCacheLength"/> and <see cref="ProjectileID.Sets.TrailingMode"/> to be used properly.
+		/// </summary>
 		public int[] oldSpriteDirection = new int[10];
-		public bool minion;
 		public float minionSlots;
 		public int minionPos;
 		public int restrikeDelay;
@@ -112,9 +_,34 @@
 		public bool ownerHitCheck;
 		public int[] playerImmune = new int[255];
 		public string miscText = "";
-		public bool melee;
-		public bool ranged;
-		public bool magic;
+		internal bool melee {
+			get => CountsAsClass(DamageClass.Melee);
+			set {
+				if (value)
+					DamageType = DamageClass.Melee;
+				else if (DamageType == DamageClass.Melee)
+					DamageType = DamageClass.Default;
+			}
+		}
+		internal bool magic {
+			get => CountsAsClass(DamageClass.Magic);
+			set {
+				if (value)
+					DamageType = DamageClass.Magic;
+				else if (DamageType == DamageClass.Magic)
+					DamageType = DamageClass.Default;
+			}
+		}
+		internal bool ranged {
+			get => CountsAsClass(DamageClass.Ranged);
+			set {
+				if (value)
+					DamageType = DamageClass.Ranged;
+				else if (DamageType == DamageClass.Ranged)
+					DamageType = DamageClass.Default;
+			}
+		}
+		public bool minion;
 		public bool coldDamage;
 		public bool noEnchantments;
 		public bool noEnchantmentVisuals;
@@ -144,7 +_,12 @@
 		private static List<int> _ai156_blacklistedTargets = new List<int>();
 		private static float[] _CompanionCubeScreamCooldown = new float[255];
 
-		public string Name => Lang.GetProjectileName(type).Value;
+		private string nameOverride = null;
+		public string Name
+		{
+			get => nameOverride ?? Lang.GetProjectileName(type).Value;
+			set => nameOverride = value;
+		}
 
 		public bool WipableTurret {
 			get {
@@ -185,15 +_,15 @@
 		public static void InitializeStaticThings() {
 			perIDStaticNPCImmunity = new uint[972][];
 			for (int i = 0; i < perIDStaticNPCImmunity.Length; i++) {
-				perIDStaticNPCImmunity[i] = new uint[200];
+				perIDStaticNPCImmunity[i] = new uint[Main.maxNPCs];
 			}
 
 			WorldGen.Hooks.OnWorldLoad += ResetImmunity;
 		}
 
 		public static void ResetImmunity() {
-			for (int i = 0; i < 972; i++) {
+			for (int i = 0; i < perIDStaticNPCImmunity.Length; i++) {
-				for (int j = 0; j < 200; j++) {
+				for (int j = 0; j < Main.maxNPCs; j++) {
 					perIDStaticNPCImmunity[i][j] = 0u;
 				}
 			}
@@ -221,7 +_,39 @@
 			}
 		}
 
+		public void CloneDefaults(int TypeToClone) {
+			int originalType = type;
+			var originalModProjectile = ModProjectile;
+			var originalGlobals = globalProjectiles;
+			SetDefaults(TypeToClone);
+			type = originalType;
+			ModProjectile = originalModProjectile;
+			globalProjectiles = originalGlobals;
+
+			int num = ProjectileID.Sets.TrailCacheLength[type];
+			if (num != oldPos.Length) {
+				Array.Resize(ref oldPos, num);
+				Array.Resize(ref oldRot, num);
+				Array.Resize(ref oldSpriteDirection, num);
+			}
+
+			for (int i = 0; i < oldPos.Length; i++) {
+				oldPos[i].X = 0f;
+				oldPos[i].Y = 0f;
+				oldRot[i] = 0f;
+				oldSpriteDirection[i] = 0;
+			}
+		}
+
 		public void SetDefaults(int Type) {
+			ModProjectile = null;
+			globalProjectiles = new Instanced<GlobalProjectile>[0];
+			DamageType = DamageClass.Default;
+			ArmorPenetration = 0;
+			CritChance = 0;
+			WhipSettings = default;
+			ContinuouslyUpdateDamage = false;
+			nameOverride = null;
 			ownerHitCheckDistance = 1000f;
 			counterweight = false;
 			sentry = false;
@@ -269,9 +_,11 @@
 			minionSlots = 0f;
 			soundDelay = 0;
 			spriteDirection = 1;
+			/*
 			melee = false;
 			ranged = false;
 			magic = false;
+			*/
 			ownerHitCheck = false;
 			hide = false;
 			lavaWet = false;
@@ -1806,6 +_,7 @@
 				ignoreWater = true;
 			}
 			else if (type == 150 || type == 151 || type == 152) {
+				ArmorPenetration = 10;
 				width = 28;
 				height = 28;
 				aiStyle = 4;
@@ -2145,6 +_,7 @@
 				trap = true;
 			}
 			else if (type == 189) {
+				ArmorPenetration = 10;
 				width = 8;
 				height = 8;
 				aiStyle = 36;
@@ -4851,6 +_,7 @@
 				netImportant = true;
 			}
 			else if (type == 493 || type == 494) {
+				ArmorPenetration = 10;
 				width = 32;
 				height = 32;
 				aiStyle = 4;
@@ -5119,6 +_,7 @@
 				penetrate = -1;
 			}
 			else if (type == 532) {
+				ArmorPenetration = 25;
 				width = 16;
 				height = 16;
 				aiStyle = 1;
@@ -5525,6 +_,7 @@
 				extraUpdates = 2;
 			}
 			else if (type == 595) {
+				ArmorPenetration = 20;
 				width = 68;
 				height = 64;
 				aiStyle = 75;
@@ -6609,6 +_,7 @@
 				hide = true;
 			}
 			else if (type == 723 || type == 724 || type == 725 || type == 726) {
+				ArmorPenetration = 25;
 				width = 24;
 				height = 24;
 				aiStyle = 5;
@@ -7230,6 +_,7 @@
 				ranged = true;
 			}
 			else if (type == 864) {
+				ArmorPenetration = 25;
 				netImportant = true;
 				width = 10;
 				height = 10;
@@ -7589,6 +_,7 @@
 					coldDamage = true;
 			}
 			else if (type == 916) {
+				ArmorPenetration = 25;
 				width = 18;
 				height = 18;
 				aiStyle = 176;
@@ -7611,6 +_,7 @@
 				height = 96;
 			}
 			else if (type == 917) {
+				ArmorPenetration = 30;
 				width = 30;
 				height = 30;
 				aiStyle = 177;
@@ -8017,6 +_,7 @@
 				alpha = 255;
 			}
 			else if (type == 964) {
+				ArmorPenetration = 20;
 				width = 40;
 				height = 40;
 				aiStyle = 187;
@@ -8054,6 +_,7 @@
 				alpha = 255;
 			}
 			else if (type == 969) {
+				ArmorPenetration = 10;
 				width = 56;
 				height = 64;
 				aiStyle = 177;
@@ -8088,9 +_,18 @@
 				alpha = 255;
 				hide = true;
 			}
+			/*
 			else {
 				active = false;
 			}
+			*/
+
+			// tML:
+			// this tells all vanilla summon class projectiles THAT AREN'T WHIPS to actually use the corresponding DamageClass
+			if (type < ProjectileID.Count && (minion || sentry || ProjectileID.Sets.MinionShot[type] || ProjectileID.Sets.SentryShot[type]))
+				DamageType = DamageClass.Summon;
+
+			ProjectileLoader.SetDefaults(this);
 
 			width = (int)((float)width * scale);
 			height = (int)((float)height * scale);
@@ -8102,6 +_,7 @@
 			height = 18;
 			aiStyle = 165;
 			friendly = true;
+			DamageType = DamageClass.SummonMeleeSpeed;
 			penetrate = -1;
 			tileCollide = false;
 			scale = 1f;
@@ -8109,6 +_,7 @@
 			extraUpdates = 1;
 			usesLocalNPCImmunity = true;
 			localNPCHitCooldown = -1;
+			VanillaWhipSettings(this, out WhipSettings.Segments, out WhipSettings.RangeMultiplier);
 		}
 
 		public static int GetNextSlot() {
@@ -8123,6 +_,10 @@
 			return result;
 		}
 
+		/// <summary>
+		/// <inheritdoc cref="Projectile.NewProjectile(IEntitySource, float, float, float, float, int, int, float, int, float, float)"/>
+		/// <br/><br/>This particular overload uses a Vector2 instead of X and Y to determine the actual spawn position and a Vector2 to dictate the initial velocity.
+		/// </summary>
 		public static int NewProjectile(IEntitySource spawnSource, Vector2 position, Vector2 velocity, int Type, int Damage, float KnockBack, int Owner = 255, float ai0 = 0f, float ai1 = 0f) => NewProjectile(spawnSource, position.X, position.Y, velocity.X, velocity.Y, Type, Damage, KnockBack, Owner, ai0, ai1);
 
 		public static int FindOldestProjectile() {
@@ -8138,6 +_,24 @@
 			return result;
 		}
 
+		/// <summary>
+		/// Spawns a projectile into the game world with the given type. The spawn position is given in world coordinates by the X and Y parameters. SpeedX and SpeedY dictate the initial velocity. Damage and KnockBack are self explanitory. Owner is the player who spawned the projectile, almost always Main.myPlayer. ai0 and ai1 will initialize the Projectile.ai[] array with the supplied values. This can be used to pass in information to the Projectile. The Projectile AI code will have to be written to utilize those values. The return value is the index of the spawned Projectile within the <see cref="Main.projectile"/> array.
+		/// <br/> Make sure that this method is called only by the client in charge of the source causing this projectile to spawn. Failure to do this will result in the projectile spawning once for each player in the world. For example, if Player code uses this method, make sure to first check <code>if(Main.myPlayer == Player.whoAmI)</code> to ensure that only the local player spawns the projectile.
+		/// <br/> Projectiles spawning other projectiles should check <code>if(Main.myPlayer == Projectile.owner)</code>
+		/// <br/> If the source is an NPC or non-player owned projectile, checking <code>if (Main.netMode != NetmodeID.MultiplayerClient)</code> will ensure that clients don't attempt to spawn the projectile.
+		/// </summary>
+		/// <param name="spawnSource"></param>
+		/// <param name="X"></param>
+		/// <param name="Y"></param>
+		/// <param name="SpeedX"></param>
+		/// <param name="SpeedY"></param>
+		/// <param name="Type">Either an <see cref="ProjectileID"/> entry or <see cref="ModContent.ProjectileType{T}"/>, for example <see cref="ProjectileID.FireArrow"/> or ModContent.ProjectileType&lt;MyModProjectile&gt;()</param>
+		/// <param name="Damage"></param>
+		/// <param name="KnockBack"></param>
+		/// <param name="Owner"></param>
+		/// <param name="ai0"></param>
+		/// <param name="ai1"></param>
+		/// <returns></returns>
 		public static int NewProjectile(IEntitySource spawnSource, float X, float Y, float SpeedX, float SpeedY, int Type, int Damage, float KnockBack, int Owner = 255, float ai0 = 0f, float ai1 = 0f) {
 			int num = 1000;
 			for (int i = 0; i < 1000; i++) {
@@ -8169,6 +_,7 @@
 			projectile.honeyWet = Collision.honey;
 			Main.projectileIdentity[Owner, num] = num;
 			FindBannerToAssociateTo(spawnSource, projectile);
+			HandlePlayerStatModifiers(spawnSource, projectile);
 			if (projectile.aiStyle == 1) {
 				while (projectile.velocity.X >= 16f || projectile.velocity.X <= -16f || projectile.velocity.Y >= 16f || projectile.velocity.Y < -16f) {
 					projectile.velocity.X *= 0.97f;
@@ -8203,7 +_,7 @@
 				projectile.ai[1] = projectile.position.Y;
 			}
 
-			if (Type > 0 && Type < 972) {
+			if (Type > 0) {
 				if (ProjectileID.Sets.NeedsUUID[Type])
 					projectile.projUUID = projectile.identity;
 
@@ -8214,8 +_,11 @@
 				}
 			}
 
+			// Copied at the bottom. Gotos would be messy.
+			/*
 			if (Main.netMode != 0 && Owner == Main.myPlayer)
 				NetMessage.SendData(27, -1, -1, null, num);
+			*/
 
 			if (Owner == Main.myPlayer) {
 				if (ProjectileID.Sets.IsAGolfBall[Type] && Damage <= 0) {
@@ -8325,11 +_,23 @@
 
 				if (Type == 777 || Type == 781 || Type == 794 || Type == 797 || Type == 800 || Type == 785 || Type == 788 || Type == 791 || Type == 903 || Type == 904 || Type == 905 || Type == 906 || Type == 910 || Type == 911)
 					projectile.timeLeft = 180;
+
+				// Copied from 1.3, moved from Shoot context to OnSpawn with matching logic
+				if (Main.netMode != NetmodeID.Server) {
+					Player throwingPlayer = Main.player[Owner];
+					if (throwingPlayer.AnyThrownCostReduction && throwingPlayer.HeldItem.CountsAsClass(DamageClass.Throwing) && spawnSource is EntitySource_ItemUse_WithAmmo)
+						projectile.noDropItem = true;
+				}
 			}
 
 			if (Type == 249)
 				projectile.frame = Main.rand.Next(5);
 
+			ProjectileLoader.OnSpawn(projectile, spawnSource);
+
+			if (Main.netMode != 0 && Owner == Main.myPlayer)
+				NetMessage.SendData(27, -1, -1, null, num);
+
 			return num;
 		}
 
@@ -8788,11 +_,11 @@
 				return;
 
 			Main.player[Main.myPlayer].ghostDmg += num;
-			int[] array = new int[200];
+			int[] array = new int[Main.maxNPCs];
 			int num4 = 0;
-			_ = new int[200];
+			_ = new int[200]; // ???
 			int num5 = 0;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (!Main.npc[i].CanBeChasedBy(this))
 					continue;
 
@@ -9052,9 +_,18 @@
 		}
 
 		public void Damage() {
+			bool? shouldHitAnything = ProjectileLoader.CanDamage(this);
+			if (shouldHitAnything.HasValue) {
+				if (shouldHitAnything.Value)
+					goto SkipVanillaLogic;
+				else
+					return;
+			}
+
-			if (type == 18 || type == 72 || type == 86 || type == 87 || aiStyle == 31 || aiStyle == 32 || type == 226 || type == 378 || type == 613 || type == 650 || type == 882 || type == 888 || type == 895 || type == 896 || (type == 434 && localAI[0] != 0f) || type == 439 || type == 444 || (type == 451 && ((int)(ai[0] - 1f) / penetrate == 0 || ai[1] < 5f) && ai[0] != 0f) || type == 500 || type == 653 || type == 460 || type == 633 || type == 600 || type == 601 || type == 602 || type == 535 || (type == 631 && localAI[1] == 0f) || type == 651 || (type == 188 && localAI[0] < 5f) || (aiStyle == 137 && ai[0] != 0f) || aiStyle == 138 || (type == 261 && velocity.Length() < 1.5f) || (type == 818 && ai[0] < 1f) || type == 831 || type == 970 || (type == 833 && ai[0] == 4f) || (type == 834 && ai[0] == 4f) || (type == 835 && ai[0] == 4f) || (type == 281 && ai[0] == -3f) || ((type == 598 || type == 636 || type == 614 || type == 971) && ai[0] == 1f) || (type == 923 && localAI[0] <= 60f) || (type == 919 && localAI[0] <= 60f) || (aiStyle == 15 && ai[0] == 0f && localAI[1] <= 12f) || type == 861 || (aiStyle == 93 && ai[0] != 0f && ai[0] != 2f) || (aiStyle == 10 && localAI[1] == -1f) || (Main.projPet[type] && type != 266 && type != 407 && type != 317 && (type != 388 || ai[0] != 2f) && (type < 390 || type > 392) && (type < 393 || type > 395) && (type != 533 || !(ai[0] >= 6f) || !(ai[0] <= 8f)) && (type < 625 || type > 628) && (type != 755 || ai[0] == 0f) && (type != 946 || ai[0] == 0f) && type != 758 && type != 951 && type != 963 && (type != 759 || frame == Main.projFrames[type] - 1) && type != 833 && type != 834 && type != 835 && type != 864 && (type != 623 || ai[0] != 2f)))
+			if (type == 18 || type == 72 || type == 86 || type == 87 || aiStyle == 31 || aiStyle == 32 || type == 226 || type == 378 || type == 613 || type == 650 || type == 882 || type == 888 || type == 895 || type == 896 || (type == 434 && localAI[0] != 0f) || type == 439 || type == 444 || (type == 451 && ((int)(ai[0] - 1f) / penetrate == 0 || ai[1] < 5f) && ai[0] != 0f) || type == 500 || type == 653 || type == 460 || type == 633 || type == 600 || type == 601 || type == 602 || type == 535 || (type == 631 && localAI[1] == 0f) || type == 651 || (type == 188 && localAI[0] < 5f) || (aiStyle == 137 && ai[0] != 0f) || aiStyle == 138 || (type == 261 && velocity.Length() < 1.5f) || (type == 818 && ai[0] < 1f) || type == 831 || type == 970 || (type == 833 && ai[0] == 4f) || (type == 834 && ai[0] == 4f) || (type == 835 && ai[0] == 4f) || (type == 281 && ai[0] == -3f) || ((type == 598 || type == 636 || type == 614 || type == 971) && ai[0] == 1f) || (type == 923 && localAI[0] <= 60f) || (type == 919 && localAI[0] <= 60f) || (aiStyle == 15 && ai[0] == 0f && localAI[1] <= 12f) || type == 861 || (aiStyle == 93 && ai[0] != 0f && ai[0] != 2f) || (aiStyle == 10 && localAI[1] == -1f) || (Main.projPet[type] && type != 266 && type != 407 && type != 317 && (type != 388 || ai[0] != 2f) && (type < 390 || type > 392) && (type < 393 || type > 395) && (type != 533 || !(ai[0] >= 6f) || !(ai[0] <= 8f)) && (type < 625 || type > 628) && (type != 755 || ai[0] == 0f) && (type != 946 || ai[0] == 0f) && type != 758 && type != 951 && type != 963 && (type != 759 || frame == Main.projFrames[type] - 1) && type != 833 && type != 834 && type != 835 && type != 864 && (type != 623 || ai[0] != 2f) && !ProjectileLoader.MinionContactDamage(this)))
 				return;
 
+			SkipVanillaLogic:
 			Rectangle myRect = new Rectangle((int)base.position.X, (int)base.position.Y, width, height);
 			if (type == 85 || type == 101) {
 				int num = 30;
@@ -9080,6 +_,7 @@
 				myRect.Height += num3 * 2;
 			}
 
+			ProjectileLoader.ModifyDamageHitbox(this, ref myRect);
 			if (friendly && owner == Main.myPlayer && !npcProj) {
 				if ((aiStyle == 16 && !ProjectileID.Sets.RocketsSkipDamageForPlayers[type] && (timeLeft <= 1 || type == 108 || type == 164)) || (type == 286 && localAI[1] == -1f)) {
 					int myPlayer = Main.myPlayer;
@@ -9211,7 +_,9 @@
 							num5 = 1.9f;
 							break;
 					}
+
 				}
+				ProjectileLoader.ModifyDamageScaling(this, ref num5);
 
 				if (damage > 0) {
 					int[] array = localNPCImmunity;
@@ -9221,11 +_,26 @@
 							array = projectile.localNPCImmunity;
 					}
 
+					//Patch context
-					for (int i = 0; i < 200; i++) {
+					for (int i = 0; i < Main.maxNPCs; i++) {
 						bool flag = (!usesLocalNPCImmunity && !usesIDStaticNPCImmunity) || (usesLocalNPCImmunity && array[i] == 0) || (usesIDStaticNPCImmunity && IsNPCIndexImmuneToProjectileType(type, i));
 						if (!(Main.npc[i].active && !Main.npc[i].dontTakeDamage && flag) || (Main.npc[i].aiStyle == 112 && Main.npc[i].ai[2] > 1f))
 							continue;
 
+						bool? modCanHit = ProjectileLoader.CanHitNPC(this, Main.npc[i]);
+						if (modCanHit == false)
+							continue;
+
+						bool? modCanBeHit = NPCLoader.CanBeHitByProjectile(Main.npc[i], this);
+						if (modCanBeHit == false)
+							continue;
+
+						bool? modCanHit2 = PlayerLoader.CanHitNPCWithProj(this, Main.npc[i]);
+						if (modCanHit2 == false)
+							continue;
+
+						bool canHitFlag = modCanBeHit == true || modCanHit == true || modCanHit2 == true; //If any hook forces damage: ignore vanilla conditions
+
 						Main.npc[i].position += Main.npc[i].netOffset;
 						bool flag2 = !Main.npc[i].friendly;
 						flag2 |= (type == 318);
@@ -9235,8 +_,12 @@
 							flag2 = false;
 
 						bool flag3 = Main.npc[i].friendly && !Main.npc[i].dontTakeDamageFromHostiles;
-						if ((friendly && flag2) || (hostile && flag3)) {
+						if (canHitFlag || (friendly && flag2) || (hostile && flag3)) {
 							bool flag4 = maxPenetrate == 1 && !usesLocalNPCImmunity && !usesIDStaticNPCImmunity;
+
+							if (canHitFlag)
+								flag4 = true;
+
 							if (owner < 0 || Main.npc[i].immune[owner] == 0 || flag4) {
 								bool flag5 = false;
 								if (type == 11 && (Main.npc[i].type == 47 || Main.npc[i].type == 57))
@@ -9248,6 +_,9 @@
 								else if (Main.npc[i].immortal && npcProj)
 									flag5 = true;
 
+								if (canHitFlag)
+									flag5 = false;
+
 								if (!flag5 && (Main.npc[i].noTileCollide || !ownerHitCheck || CanHitWithMeleeWeapon(Main.npc[i]))) {
 									bool flag6 = false;
 									if (Main.npc[i].type == 414) {
@@ -9348,9 +_,14 @@
 
 										float num7 = knockBack;
 										bool flag7 = false;
-										int num8 = Main.player[owner].armorPenetration;
+										// int num8 = Main.player[owner].armorPenetration;
 										bool flag8 = !npcProj && !trap;
 										switch (type) {
+											// tML:
+											// armor penetration is handled in a more flexible way now, so all this nonsense is now completely unnecessary
+											// please refer to the correspondin' cases in SetDefaults for more information on how vanilla armor penetration values are set
+											// - thomas
+											/*
 											case 864:
 												num8 += 25;
 												break;
@@ -9390,6 +_,7 @@
 											case 969:
 												num8 += 10;
 												break;
+											*/
 											case 877:
 											case 878:
 											case 879:
@@ -9401,7 +_,7 @@
 										}
 
 										int num9 = (int)((float)damage * num5);
-										if (type > 0 && type < 972 && ProjectileID.Sets.StardustDragon[type]) {
+										if (type > 0 && ProjectileID.Sets.StardustDragon[type]) {
 											float value2 = (scale - 1f) * 100f;
 											value2 = Utils.Clamp(value2, 0f, 50f);
 											num9 = (int)((float)num9 * (1f + value2 * 0.23f));
@@ -9431,15 +_,30 @@
 										}
 
 										if (flag8) {
+											/*
 											if (melee && Main.rand.Next(1, 101) <= Main.player[owner].meleeCrit)
 												flag7 = true;
 
+											// Extra patch context.
+
 											if (ranged && Main.rand.Next(1, 101) <= Main.player[owner].rangedCrit)
 												flag7 = true;
 
 											if (magic && Main.rand.Next(1, 101) <= Main.player[owner].magicCrit)
 												flag7 = true;
 
+											tML:
+											the above code only accounts for the "three" vanilla classes that are capable of crits, and doesn't account for throwin'
+											it also doesn't account for any modded damage types, and so a change was needed in order to allow it to work with new classes
+											on top of this, the change from usin' the player's class crit to usin' the projectile's crit chance is important
+											it's part of the fix for the infamous "crit swap" exploit, as well as a larger overall fix to crit chance
+
+											- thomas
+											*/
+
+											if (DamageType.UseStandardCritCalcs && Main.rand.Next(100) < CritChance)
+												flag7 = true;
+
 											int num15 = type;
 											if ((uint)(num15 - 688) <= 2u) {
 												if (Main.player[owner].setMonkT3) {
@@ -9748,7 +_,7 @@
 												num21 = (int)((double)num21 * 0.75);
 										}
 
-										if (Main.netMode != 2 && nPC.type == 439 && type >= 0 && type <= 972 && ProjectileID.Sets.CultistIsResistantTo[type])
+										if (Main.netMode != 2 && nPC.type == 439 && type >= 0 && ProjectileID.Sets.CultistIsResistantTo[type])
 											num21 = (int)((float)num21 * 0.75f);
 
 										if (type == 497 && penetrate != 1) {
@@ -9844,7 +_,7 @@
 											int num30 = 0;
 											int num31 = 700;
 											int num32 = 20;
-											for (int l = 0; l < 200; l++) {
+											for (int l = 0; l < Main.maxNPCs; l++) {
 												if (l == i || !Main.npc[l].CanBeChasedBy(this))
 													continue;
 
@@ -9878,6 +_,10 @@
 											Main.player[owner].ClearBuff(198);
 										}
 
+										// Essentially, the following block is moved to execute later on.
+										goto VanillaOnHitEffectsEnd;
+
+										VanillaOnHitEffectsStart:
 										StatusNPC(i);
 										if (flag8 && nPC.life > 5)
 											TryDoingOnHitEffects(nPC);
@@ -9885,11 +_,14 @@
 										if (ProjectileID.Sets.ImmediatelyUpdatesNPCBuffFlags[type])
 											nPC.UpdateNPC_BuffSetFlags(lowerBuffTime: false);
 
+										// Extra patch context.
 										if (type == 317) {
 											ai[1] = -1f;
 											netUpdate = true;
 										}
+										goto PostModifyHit;
 
+										VanillaOnHitEffectsEnd:
 										int num34 = base.direction;
 										switch (type) {
 											case 697:
@@ -9906,14 +_,26 @@
 											if (ai[0] == 0f)
 												num7 *= 0.25f;
 
+										// Extra context
+
 											if (ai[0] == 6f)
 												num7 *= 0.5f;
 										}
 
+										ProjectileLoader.ModifyHitNPC(this, nPC, ref num21, ref num7, ref flag7, ref num34);
+										NPCLoader.ModifyHitByProjectile(nPC, this, ref num21, ref num7, ref flag7, ref num34);
+										PlayerLoader.ModifyHitNPCWithProj(this, nPC, ref num21, ref num7, ref flag7, ref num34);
+
+										goto VanillaOnHitEffectsStart;
+
+										PostModifyHit:
+
-										if (flag8 && !hostile && num8 > 0)
+										if (flag8 && !hostile && ArmorPenetration > 0)
-											num21 += nPC.checkArmorPenetration(num8);
+											num21 += nPC.checkArmorPenetration(ArmorPenetration);
 
 										NPCKillAttempt attempt = new NPCKillAttempt(nPC);
+										// Extra context
+
 										int num35 = (!flag8) ? ((int)nPC.StrikeNPCNoInteraction(num21, num7, num34, flag7)) : ((int)nPC.StrikeNPC(num21, num7, num34, flag7));
 										if (flag8 && attempt.DidNPCDie())
 											Main.player[owner].OnKillNPC(ref attempt, this);
@@ -10169,9 +_,16 @@
 											}
 										}
 
+										// Extra patch context.
+
 										if (type == 710)
 											BetsySharpnel(i);
 
+										// Patching: See ModifyHitX above for locals
+										ProjectileLoader.OnHitNPC(this, Main.npc[i], num21, num7, flag7);
+										NPCLoader.OnHitByProjectile(Main.npc[i], this, num21, num7, flag7);
+										PlayerLoader.OnHitNPCWithProj(this, Main.npc[i], num21, num7, flag7);
+
 										if (penetrate > 0 && type != 317 && type != 866) {
 											if (type == 357)
 												damage = (int)((double)damage * 0.8);
@@ -10318,6 +_,9 @@
 						if (!flag17 || !Colliding(myRect, player2.getRect()))
 							continue;
 
+						if (!ProjectileLoader.CanHitPvp(this, player2) || !PlayerLoader.CanHitPvpWithProj(this, player2))
+							continue;
+
 						if (aiStyle == 3) {
 							if (ai[0] == 0f) {
 								velocity.X = 0f - velocity.X;
@@ -10351,14 +_,20 @@
 							timeLeft = 1;
 
 						bool flag18 = false;
-						if (melee && Main.rand.Next(1, 101) <= Main.player[owner].meleeCrit)
+						if (melee && Main.rand.Next(1, 101) <= Main.player[owner].GetTotalCritChance(DamageClass.Melee))
 							flag18 = true;
 
+						//Patch context: ^ flag18, to be used below multiple times.
 						int num45 = Main.DamageVar((int)((float)damage * num5), Main.player[owner].luck);
+
+						ProjectileLoader.ModifyHitPvp(this, player2, ref num45, ref flag18);
+						PlayerLoader.ModifyHitPvpWithProj(this, player2, ref num45, ref flag18);
+
 						if (!player2.immune)
 							StatusPvP(m);
 
 						TryDoingOnHitEffects(player2);
+						//Patch context: num46, to be used below.
 						int num46 = (int)player2.Hurt(playerDeathReason, num45, base.direction, pvp: true, quiet: false, flag18);
 						if (num46 > 0 && Main.player[owner].ghostHeal && friendly && !hostile)
 							ghostHeal(num46, new Vector2(player2.Center.X, player2.Center.Y), player2);
@@ -10369,6 +_,9 @@
 						if ((melee || ProjectileID.Sets.IsAWhip[type]) && Main.player[owner].meleeEnchant == 7)
 							NewProjectile(GetProjectileSource_FromThis(), player2.Center.X, player2.Center.Y, player2.velocity.X, player2.velocity.Y, 289, 0, 0f, owner);
 
+						ProjectileLoader.OnHitPvp(this, player2, num46, flag18);
+						PlayerLoader.OnHitPvpWithProj(this, player2, num46, flag18);
+
 						if (Main.netMode != 0)
 							NetMessage.SendPlayerHurt(m, playerDeathReason, num45, base.direction, flag18, pvp: true, -1);
 
@@ -10397,7 +_,7 @@
 			}
 
 			if (type == 10 && Main.netMode != 1) {
-				for (int n = 0; n < 200; n++) {
+				for (int n = 0; n < Main.maxNPCs; n++) {
 					if (Main.npc[n].active && Main.npc[n].type == 534) {
 						Rectangle value6 = new Rectangle((int)Main.npc[n].position.X, (int)Main.npc[n].position.Y, Main.npc[n].width, Main.npc[n].height);
 						if (myRect.Intersects(value6))
@@ -10408,7 +_,7 @@
 
 			if ((type == 11 || type == 463) && Main.netMode != 1) {
 				bool crimson = type == 463;
-				for (int num47 = 0; num47 < 200; num47++) {
+				for (int num47 = 0; num47 < Main.maxNPCs; num47++) {
 					if (Main.npc[num47].active) {
 						Rectangle value7 = new Rectangle((int)Main.npc[num47].position.X, (int)Main.npc[num47].position.Y, Main.npc[num47].width, Main.npc[num47].height);
 						if (myRect.Intersects(value7))
@@ -10435,10 +_,12 @@
 				case 919:
 				case 923:
 				case 924:
+					// This is the cooldown slot variable.
 					num48 = 1;
 					break;
 			}
 
+			// Extra patch context.
 			int myPlayer2 = Main.myPlayer;
 			bool flag19 = Main.player[myPlayer2].active && !Main.player[myPlayer2].dead && (!Main.player[myPlayer2].immune || num48 != -1);
 			if (flag19 && type == 281)
@@ -10447,9 +_,15 @@
 			if (Main.getGoodWorld && type == 281)
 				flag19 = true;
 
+			if (ModProjectile != null)
+				num48 = ModProjectile.CooldownSlot;
+
 			if (!flag19 || !Colliding(myRect, Main.player[myPlayer2].getRect()))
 				return;
 
+			if (!ProjectileLoader.CanHitPlayer(this, Main.player[myPlayer2]) || !PlayerLoader.CanBeHitByProjectile(Main.player[myPlayer2], this))
+				return;
+
 			int direction = base.direction;
 			direction = ((!(Main.player[myPlayer2].position.X + (float)(Main.player[myPlayer2].width / 2) < base.position.X + (float)(width / 2))) ? 1 : (-1));
 			if (!Main.player[myPlayer2].CanParryAgainst(Main.player[myPlayer2].Hitbox, base.Hitbox, velocity)) {
@@ -10482,7 +_,13 @@
 					}
 				}
 
-				if (Main.player[myPlayer2].Hurt(PlayerDeathReason.ByProjectile(-1, whoAmI), num52, direction, pvp: false, quiet: false, Crit: false, num48) > 0.0 && !Main.player[myPlayer2].dead)
+				bool crit = false;
+				ProjectileLoader.ModifyHitPlayer(this, Main.player[myPlayer2], ref num52, ref crit);
+				PlayerLoader.ModifyHitByProjectile(Main.player[myPlayer2], this, ref num52, ref crit);
+
+				int realDamage = (int)Main.player[myPlayer2].Hurt(PlayerDeathReason.ByProjectile(-1, whoAmI), num52, direction, pvp: false, quiet: false, Crit: crit, num48);
+
+				if (realDamage > 0 && !Main.player[myPlayer2].dead)
 					StatusPlayer(myPlayer2);
 
 				if (trap) {
@@ -10490,6 +_,9 @@
 					if (Main.player[myPlayer2].dead)
 						AchievementsHelper.HandleSpecialEvent(Main.player[myPlayer2], 4);
 				}
+
+				ProjectileLoader.OnHitPlayer(this, Main.player[myPlayer2], realDamage, crit);
+				PlayerLoader.OnHitByProjectile(Main.player[myPlayer2], this, realDamage, crit);
 			}
 
 			if (true) {
@@ -10542,7 +_,7 @@
 			return num;
 		}
 
-		private static void EmitBlackLightningParticles(NPC targetNPC) {
+		public static void EmitBlackLightningParticles(NPC targetNPC) {
 			ParticleOrchestrator.RequestParticleSpawn(clientOnly: false, ParticleOrchestraType.BlackLightningHit, new ParticleOrchestraSettings {
 				PositionInWorld = targetNPC.Center
 			});
@@ -10577,7 +_,7 @@
 
 			localAI[0] = 1000f;
 			List<NPC> list = new List<NPC>();
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (nPC.CanBeChasedBy(this) && Distance(nPC.Center) < 800f)
 					list.Add(nPC);
@@ -10673,10 +_,15 @@
 				}
 			}
 
+			ProjectileLoader.CutTiles(this);
 			AchievementsHelper.CurrentlyMining = false;
 		}
 
 		private bool CanCutTiles() {
+			bool? canCutTiles = ProjectileLoader.CanCutTiles(this);
+			if (canCutTiles.HasValue)
+				return canCutTiles.Value;
+
 			if (aiStyle != 45 && aiStyle != 137 && aiStyle != 92 && aiStyle != 105 && aiStyle != 106 && !ProjectileID.Sets.IsAGolfBall[type] && type != 463 && type != 69 && type != 70 && type != 621 && type != 10 && type != 11 && type != 379 && type != 407 && type != 476 && type != 623 && (type < 625 || type > 628) && type != 833 && type != 834 && type != 835 && type != 818 && type != 831 && type != 820 && type != 864)
 				return type != 970;
 
@@ -10862,6 +_,10 @@
 				}
 			}
 
+			bool? modColliding = ProjectileLoader.Colliding(this, myRect, targetRect);
+			if (modColliding.HasValue)
+				return modColliding.Value;
+
 			if (myRect.Intersects(targetRect))
 				return true;
 
@@ -11375,7 +_,7 @@
 			if (Main.netMode == 1 && (ProjectileID.Sets.IsAGolfBall[type] || type == 820)) {
 				int num = (int)(position.X + (float)(width / 2)) / 16;
 				int num2 = (int)(position.Y + (float)(height / 2)) / 16;
-				if (Main.tile[num, num2] == null)
+				if (!Main.sectionManager.TileLoaded(num, num2))
 					return;
 			}
 
@@ -11395,9 +_,9 @@
 				if (!noEnchantmentVisuals)
 					UpdateEnchantmentVisuals();
 
-				if (numUpdates == -1 && (minion || sentry)) {
+				if ((minion || sentry || ContinuouslyUpdateDamage)) {
 					Player player = Main.player[owner];
-					damage = (int)((float)originalDamage * player.minionDamage + (float)player.minionAddDamage + 5E-06f);
+					damage = (int)player.GetTotalDamage(DamageType).ApplyTo(originalDamage);
 				}
 
 				if (minion && numUpdates == -1 && type != 625 && type != 628) {
@@ -11456,7 +_,7 @@
 				}
 
 				if (usesLocalNPCImmunity) {
-					for (int k = 0; k < 200; k++) {
+					for (int k = 0; k < Main.maxNPCs; k++) {
 						if (localNPCImmunity[k] > 0)
 							localNPCImmunity[k]--;
 					}
@@ -12121,8 +_,21 @@
 					overrideHeight = 4;
 				}
 
+				Vector2 hitboxCenterFrac = vector ?? new Vector2(0.5f);
+				int num = (overrideWidth != -1) ? overrideWidth : base.width;
+				int num2 = (overrideHeight != -1) ? overrideHeight : base.height;
+
+				if (!ProjectileLoader.TileCollideStyle(this, ref num, ref num2, ref flag6, ref hitboxCenterFrac)) {
+				}
-				if (((type != 440 && type != 449 && type != 606) || ai[1] != 1f) && (type != 466 || localAI[1] != 1f) && (type != 580 || !(localAI[1] > 0f)) && (type != 640 || !(localAI[1] > 0f))) {
+				else if (((type != 440 && type != 449 && type != 606) || ai[1] != 1f) && (type != 466 || localAI[1] != 1f) && (type != 580 || !(localAI[1] > 0f)) && (type != 640 || !(localAI[1] > 0f))) {
+					// base.center isn't correct, we have to use position to get a right value
+					Vector2 center = base.position + new Vector2(base.width, base.height) * 0.5f;
+					Vector2 vector2 = center - new Vector2(num, num2) * hitboxCenterFrac;
 					if (aiStyle == 10) {
+						base.velocity = Collision.TileCollision(vector2, base.velocity, num, num2, flag6, flag6);
+						if (type >= ProjectileID.CopperCoinsFalling && type <= ProjectileID.PlatinumCoinsFalling)
+							base.velocity = Collision.AnyCollisionWithSpecificTiles(vector2, base.velocity, num, num2, TileID.Sets.Falling, evenActuated: true);
+						/* This section was rewriten above so it is affected by ProjectileLoader.TileCollideStyle
 						if (type >= 736 && type <= 738) {
 							base.velocity = Collision.TileCollision(base.position, base.velocity, base.width, base.height, flag6, flag6);
 						}
@@ -12136,13 +_,17 @@
 						else {
 							base.velocity = Collision.TileCollision(base.position, base.velocity, base.width, base.height, flag6, flag6);
 						}
+						*/
 					}
 					else {
+						/* This section was moved to before the ProjectileLoader.TileCollideStyle call
 						Vector2 vector2 = base.position;
 						int num = (overrideWidth != -1) ? overrideWidth : base.width;
 						int num2 = (overrideHeight != -1) ? overrideHeight : base.height;
+
 						if (overrideHeight != -1 || overrideWidth != -1)
 							vector2 = (vector.HasValue ? (base.Center - new Vector2(num, num2) * vector.Value) : new Vector2(base.position.X + (float)(base.width / 2) - (float)(num / 2), base.position.Y + (float)(base.height / 2) - (float)(num2 / 2)));
+						*/
 
 						if (wet) {
 							if (honeyWet) {
@@ -12395,7 +_,9 @@
 						}
 					}
 
+					if (!ProjectileLoader.OnTileCollide(this, lastVelocity)) {
+					}
-					if (type == 663 || type == 665 || type == 667 || type == 677 || type == 678 || type == 679 || type == 691 || type == 692 || type == 693 || type == 688 || type == 689 || type == 690) {
+					else if (type == 663 || type == 665 || type == 667 || type == 677 || type == 678 || type == 679 || type == 691 || type == 692 || type == 693 || type == 688 || type == 689 || type == 690) {
 						base.position += base.velocity;
 						base.velocity = Vector2.Zero;
 					}
@@ -12800,7 +_,7 @@
 									int num23 = 0;
 									int num24 = 700;
 									int num25 = 20;
-									for (int k = 0; k < 200; k++) {
+									for (int k = 0; k < Main.maxNPCs; k++) {
 										if (!Main.npc[k].CanBeChasedBy(this))
 											continue;
 
@@ -13326,6 +_,9 @@
 			if (aiStyle == 4 || aiStyle == 38 || aiStyle == 84 || aiStyle == 148 || (aiStyle == 7 && ai[0] == 2f) || ((type == 440 || type == 449 || type == 606) && ai[1] == 1f) || (aiStyle == 93 && ai[0] < 0f) || type == 540 || type == 756 || type == 818 || type == 856 || type == 961 || type == 933 || ProjectileID.Sets.IsAGolfBall[type])
 				return;
 
+			if (!ProjectileLoader.ShouldUpdatePosition(this))
+				return;
+
 			if (wet)
 				position += wetVelocity;
 			else
@@ -13439,12 +_,22 @@
 				fisher.heightLevel = 4;
 
 			FishingCheck_RollDropLevels(fisher.fishingLevel, out fisher.common, out fisher.uncommon, out fisher.rare, out fisher.veryrare, out fisher.legendary, out fisher.crate);
+			PlayerLoader.ModifyFishingAttempt(Main.player[owner], ref fisher);
 			FishingCheck_ProbeForQuestFish(ref fisher);
 			FishingCheck_RollEnemySpawns(ref fisher);
 			FishingCheck_RollItemDrop(ref fisher);
 			bool flag = false;
+			AdvancedPopupRequest sonar = new AdvancedPopupRequest();
+			//Bobber position as default
+			Vector2 sonarPosition = new Vector2(position.X, position.Y);
+			PlayerLoader.CatchFish(Main.player[owner], fisher, ref fisher.rolledItemDrop, ref fisher.rolledEnemySpawn, ref sonar, ref sonarPosition);
+
+			if(sonar.Text != null && Main.player[owner].sonarPotion) {
+				PopupText.AssignAsSonarText(PopupText.NewText(sonar,sonarPosition));
+			}
+
 			if (fisher.rolledItemDrop > 0) {
-				if (Main.player[owner].sonarPotion) {
+				if (sonar.Text == null && Main.player[owner].sonarPotion) {
 					Item item = new Item();
 					item.SetDefaults(fisher.rolledItemDrop);
 					item.position = position;
@@ -13459,7 +_,7 @@
 			}
 
 			if (fisher.rolledEnemySpawn > 0) {
-				if (Main.player[owner].sonarPotion)
+				if (sonar.Text == null && Main.player[owner].sonarPotion)
 					PopupText.AssignAsSonarText(PopupText.NewText(PopupTextContext.SonarAlert, fisher.rolledEnemySpawn, base.Center, stay5TimesLonger: false));
 
 				float num4 = fisher.fishingLevel;
@@ -13933,9 +_,11 @@
 				while (Main.tile[i, num].liquid > 0 && !WorldGen.SolidTile(i, num) && num < Main.maxTilesY - 10) {
 					numWaters++;
 					num++;
+					//patch file: flag, num4
 					if (Main.tile[i, num].lava())
 						lava = true;
 					else if (Main.tile[i, num].honey())
+						//patch file: flag2
 						honey = true;
 
 					tileCoords.X = i;
@@ -14295,6 +_,9 @@
 						return 0.77f;
 					case "Random":
 						return Main.rand.NextFloat();
+					case "bluemagic123":
+					case "blushiemagic":
+						return 0.55f + (float)Math.Cos(Main.time / 120.0 * 6.2831854820251465) * 0.1f;
 				}
 			}
 
@@ -14420,6 +_,8 @@
 			}
 		}
 
+		// Original vanilla methods:
+		/*
 		public static IEntitySource GetNoneSource() => null;
 		public IEntitySource GetNPCSource_FromThis() => new EntitySource_Parent(this);
 		public IEntitySource GetProjectileSource_FromThis() => new EntitySource_Parent(this);
@@ -14428,6 +_,22 @@
 		public IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId) => new EntitySource_OnHit_ByProjectileSourceID(this, victim, projectileSourceId);
 		public IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => new EntitySource_OnHit_ByItemSourceID(this, victim, itemSourceId);
 		public static IEntitySource InheritSource(Projectile projectile) => projectile?.GetProjectileSource_FromThis();
+		*/
+
+		// Internal redirects:
+
+		internal IEntitySource GetNPCSource_FromThis() => GetSource_FromThis();
+		internal IEntitySource GetProjectileSource_FromThis() => GetSource_FromThis();
+		internal IEntitySource GetItemSource_FromThis() => GetSource_FromThis();
+		internal IEntitySource GetItemSource_DropAsItem() => GetSource_DropAsItem();
+		internal IEntitySource GetProjectileSource_OnHit(Entity victim, int projectileSourceId) => GetSource_OnHit(victim, context: ProjectileSourceID.ToContextString(projectileSourceId));
+		internal IEntitySource GetItemSource_OnHit(Entity victim, int itemSourceId) => GetSource_OnHit(victim, ItemSourceID.ToContextString(itemSourceId));
+
+		internal static IEntitySource GetNoneSource() => GetSource_None();
+
+		// Public API methods can be found in:
+		//   Entity.TML.Sources.cs;
+		//   Projectile.TML.Sources.cs (if exists);
 
 		private void AI_152_SuperStarSlash() {
 			alpha -= 10;
@@ -14452,6 +_,10 @@
 		}
 
 		public void AI() {
+			ProjectileLoader.ProjectileAI(this);
+		}
+
+		public void VanillaAI() {
 			if (aiStyle == 1) {
 				AI_001();
 			}
@@ -14789,7 +_,7 @@
 				}
 				else if (type == 166) {
 					if (owner == Main.myPlayer && this.ai[1] == 1f) {
-						for (int num22 = 0; num22 < 200; num22++) {
+						for (int num22 = 0; num22 < Main.maxNPCs; num22++) {
 							if (Main.npc[num22].active && Main.npc[num22].townNPC && Colliding(base.Hitbox, Main.npc[num22].Hitbox)) {
 								Kill();
 								return;
@@ -14991,7 +_,7 @@
 						float num39 = 800f;
 						bool flag2 = false;
 						if (this.ai[1] > 10f && this.ai[1] < 360f) {
-							for (int num40 = 0; num40 < 200; num40++) {
+							for (int num40 = 0; num40 < Main.maxNPCs; num40++) {
 								if (Main.npc[num40].CanBeChasedBy(this)) {
 									float num41 = Main.npc[num40].position.X + (float)(Main.npc[num40].width / 2);
 									float num42 = Main.npc[num40].position.Y + (float)(Main.npc[num40].height / 2);
@@ -16180,7 +_,7 @@
 					}
 
 					Rectangle rectangle2 = new Rectangle((int)base.position.X, (int)base.position.Y, base.width, base.height);
-					for (int num154 = 0; num154 < 200; num154++) {
+					for (int num154 = 0; num154 < Main.maxNPCs; num154++) {
 						if (Main.npc[num154].CanBeChasedBy(this, ignoreDontTakeDamage: true)) {
 							Rectangle value7 = new Rectangle((int)Main.npc[num154].position.X, (int)Main.npc[num154].position.Y, Main.npc[num154].width, Main.npc[num154].height);
 							if (rectangle2.Intersects(value7)) {
@@ -17840,7 +_,7 @@
 				this.ai[0] += 1f;
 				if (this.ai[0] > 30f) {
 					this.ai[0] = 30f;
-					for (int num290 = 0; num290 < 200; num290++) {
+					for (int num290 = 0; num290 < Main.maxNPCs; num290++) {
 						if (Main.npc[num290].CanBeChasedBy(this) && (!Main.npc[num290].wet || Main.npc[num290].type == 370 || type == 307)) {
 							float num291 = Main.npc[num290].position.X + (float)(Main.npc[num290].width / 2);
 							float num292 = Main.npc[num290].position.Y + (float)(Main.npc[num290].height / 2);
@@ -18063,7 +_,7 @@
 						float num310 = base.position.Y;
 						float num311 = 3000f;
 						int num312 = -1;
-						for (int num313 = 0; num313 < 200; num313++) {
+						for (int num313 = 0; num313 < Main.maxNPCs; num313++) {
 							if (Main.npc[num313].CanBeChasedBy(this)) {
 								float x = Main.npc[num313].Center.X;
 								float y = Main.npc[num313].Center.Y;
@@ -18230,7 +_,7 @@
 					float num319 = base.position.Y;
 					float num320 = 700f;
 					bool flag10 = false;
-					for (int num321 = 0; num321 < 200; num321++) {
+					for (int num321 = 0; num321 < Main.maxNPCs; num321++) {
 						if (Main.npc[num321].CanBeChasedBy(this)) {
 							float num322 = Main.npc[num321].position.X + (float)(Main.npc[num321].width / 2);
 							float num323 = Main.npc[num321].position.Y + (float)(Main.npc[num321].height / 2);
@@ -18555,7 +_,7 @@
 				bool flag14 = false;
 				float num350 = 0f;
 				float num351 = 0f;
-				for (int num352 = 0; num352 < 200; num352++) {
+				for (int num352 = 0; num352 < Main.maxNPCs; num352++) {
 					if (!Main.npc[num352].CanBeChasedBy(this))
 						continue;
 
@@ -18893,7 +_,7 @@
 				bool flag17 = false;
 				int num396 = 0;
 				if (type == 297) {
-					for (int num397 = 0; num397 < 200; num397++) {
+					for (int num397 = 0; num397 < Main.maxNPCs; num397++) {
 						if (Main.npc[num397].CanBeChasedBy(this) && Distance(Main.npc[num397].Center) < num395 && Collision.CanHit(base.Center, 1, 1, Main.npc[num397].Center, 1, 1)) {
 							float num398 = Main.npc[num397].position.X + (float)(Main.npc[num397].width / 2);
 							float num399 = Main.npc[num397].position.Y + (float)(Main.npc[num397].height / 2);
@@ -19075,7 +_,7 @@
 				}
 
 				if (!flag18) {
-					for (int num441 = 0; num441 < 200; num441++) {
+					for (int num441 = 0; num441 < Main.maxNPCs; num441++) {
 						if (Main.npc[num441].CanBeChasedBy(this)) {
 							float num442 = Main.npc[num441].position.X + (float)(Main.npc[num441].width / 2);
 							float num443 = Main.npc[num441].position.Y + (float)(Main.npc[num441].height / 2);
@@ -19259,7 +_,7 @@
 					}
 
 					if (!flag19) {
-						for (int num467 = 0; num467 < 200; num467++) {
+						for (int num467 = 0; num467 < Main.maxNPCs; num467++) {
 							if (Main.npc[num467].CanBeChasedBy(this)) {
 								float num468 = Main.npc[num467].position.X + (float)(Main.npc[num467].width / 2);
 								float num469 = Main.npc[num467].position.Y + (float)(Main.npc[num467].height / 2);
@@ -19410,7 +_,7 @@
 					}
 					else {
 						float num487 = 1000f;
-						for (int num488 = 0; num488 < 200; num488++) {
+						for (int num488 = 0; num488 < Main.maxNPCs; num488++) {
 							if (Main.npc[num488].CanBeChasedBy(this)) {
 								float num489 = Main.npc[num488].position.X + (float)(Main.npc[num488].width / 2);
 								float num490 = Main.npc[num488].position.Y + (float)(Main.npc[num488].height / 2);
@@ -19564,9 +_,9 @@
 					int num498 = (int)this.ai[0];
 					if (!Main.npc[num498].active) {
 						num498 = -1;
-						int[] array2 = new int[200];
+						int[] array2 = new int[Main.maxNPCs];
 						int num499 = 0;
-						for (int num500 = 0; num500 < 200; num500++) {
+						for (int num500 = 0; num500 < Main.maxNPCs; num500++) {
 							if (Main.npc[num500].CanBeChasedBy(this)) {
 								float num501 = Math.Abs(Main.npc[num500].position.X + (float)(Main.npc[num500].width / 2) - base.position.X + (float)(base.width / 2)) + Math.Abs(Main.npc[num500].position.Y + (float)(Main.npc[num500].height / 2) - base.position.Y + (float)(base.height / 2));
 								if (num501 < 800f) {
@@ -19625,7 +_,7 @@
 
 					if (owner == Main.myPlayer) {
 						Rectangle rectangle4 = new Rectangle((int)base.position.X, (int)base.position.Y, base.width, base.height);
-						for (int num513 = 0; num513 < 200; num513++) {
+						for (int num513 = 0; num513 < Main.maxNPCs; num513++) {
 							if (Main.npc[num513].active && !Main.npc[num513].dontTakeDamage && Main.npc[num513].lifeMax > 1) {
 								Rectangle value9 = new Rectangle((int)Main.npc[num513].position.X, (int)Main.npc[num513].position.Y, Main.npc[num513].width, Main.npc[num513].height);
 								if (rectangle4.Intersects(value9)) {
@@ -19761,7 +_,7 @@
 				Vector2 vector29 = base.position;
 				bool flag20 = false;
 				float num529 = 2000f;
-				for (int num530 = 0; num530 < 200; num530++) {
+				for (int num530 = 0; num530 < Main.maxNPCs; num530++) {
 					NPC nPC = Main.npc[num530];
 					if (nPC.CanBeChasedBy(this)) {
 						float num531 = Vector2.Distance(nPC.Center, base.Center);
@@ -20175,7 +_,7 @@
 				}
 
 				if (!flag24) {
-					for (int num569 = 0; num569 < 200; num569++) {
+					for (int num569 = 0; num569 < Main.maxNPCs; num569++) {
 						NPC nPC2 = Main.npc[num569];
 						if (nPC2.CanBeChasedBy(this)) {
 							float num570 = Vector2.Distance(nPC2.Center, base.Center);
@@ -20570,7 +_,7 @@
 				if (this.ai[0] == 0f) {
 					float num595 = 500f;
 					int num596 = -1;
-					for (int num597 = 0; num597 < 200; num597++) {
+					for (int num597 = 0; num597 < Main.maxNPCs; num597++) {
 						NPC nPC3 = Main.npc[num597];
 						float num598 = (nPC3.Center - base.Center).Length();
 						if (!(num598 >= num595) && nPC3.CanBeChasedBy(this) && Collision.CanHit(base.position, base.width, base.height, nPC3.position, nPC3.width, nPC3.height)) {
@@ -20642,7 +_,7 @@
 					localAI[0]--;
 
 				if (this.ai[0] == 0f && localAI[0] == 0f) {
-					for (int num604 = 0; num604 < 200; num604++) {
+					for (int num604 = 0; num604 < Main.maxNPCs; num604++) {
 						NPC nPC4 = Main.npc[num604];
 						if (nPC4.CanBeChasedBy(this) && (this.ai[0] == 0f || this.ai[0] == (float)(num604 + 1))) {
 							Vector2 center4 = nPC4.Center;
@@ -21244,7 +_,7 @@
 						int num678 = -1;
 						Vector2 value21 = base.Center;
 						float num679 = 250f;
-						for (int num680 = 0; num680 < 200; num680++) {
+						for (int num680 = 0; num680 < Main.maxNPCs; num680++) {
 							NPC nPC6 = Main.npc[num680];
 							if (nPC6.CanBeChasedBy(this)) {
 								Vector2 center6 = nPC6.Center;
@@ -22355,7 +_,7 @@
 						int num787 = (int)base.Center.Y / 16;
 						for (int num788 = num786 - num785; num788 <= num786 + num785; num788++) {
 							for (int num789 = num787 - num785; num789 <= num787 + num785; num789++) {
-								if (Main.rand.Next(4) == 0 && new Vector2(num786 - num788, num787 - num789).Length() < (float)num785 && num788 > 0 && num788 < Main.maxTilesX - 1 && num789 > 0 && num789 < Main.maxTilesY - 1 && Main.tile[num788, num789] != null && Main.tile[num788, num789].active() && Main.IsTileSpelunkable(Main.tile[num788, num789])) {
+								if (Main.rand.Next(4) == 0 && new Vector2(num786 - num788, num787 - num789).Length() < (float)num785 && num788 > 0 && num788 < Main.maxTilesX - 1 && num789 > 0 && num789 < Main.maxTilesY - 1 && Main.tile[num788, num789] != null && Main.tile[num788, num789].active() && Main.IsTileSpelunkable(num788, num789)) {
 									int num790 = Dust.NewDust(new Vector2(num788 * 16, num789 * 16), 16, 16, 204, 0f, 0f, 150, default(Color), 0.3f);
 									Main.dust[num790].fadeIn = 0.75f;
 									Dust dust2 = Main.dust[num790];
@@ -23195,7 +_,7 @@
 				bool flag40 = false;
 				Vector2 value52 = new Vector2(0f, 0f);
 				float num836 = 280f;
-				for (int num837 = 0; num837 < 200; num837++) {
+				for (int num837 = 0; num837 < Main.maxNPCs; num837++) {
 					if (Main.npc[num837].CanBeChasedBy(this)) {
 						float num838 = Main.npc[num837].position.X + (float)(Main.npc[num837].width / 2);
 						float num839 = Main.npc[num837].position.Y + (float)(Main.npc[num837].height / 2);
@@ -23771,7 +_,7 @@
 				}
 
 				if (this.ai[0] >= 30f && this.ai[0] % 10f == 0f && Main.netMode != 1) {
-					for (int num865 = 0; num865 < 200; num865++) {
+					for (int num865 = 0; num865 < Main.maxNPCs; num865++) {
 						NPC nPC9 = Main.npc[num865];
 						if (nPC9.type != 488 && nPC9.active && Distance(nPC9.Center) <= num860) {
 							if (nPC9.townNPC && (nPC9.FindBuffIndex(165) == -1 || nPC9.buffTime[nPC9.FindBuffIndex(165)] <= 20))
@@ -24067,7 +_,7 @@
 					if (localAI[0] >= (float)(60 * num888)) {
 						flag44 = true;
 					}
-					else if (num889 < 0 || num889 >= 200) {
+					else if (num889 < 0 || num889 >= Main.maxNPCs) {
 						flag44 = true;
 					}
 					else if (Main.npc[num889].active && !Main.npc[num889].dontTakeDamage) {
@@ -24084,7 +_,7 @@
 						Kill();
 
 					if (!flag44 && type == 971) {
-						if (num889 > 0 && num889 < 200 && timeLeft % 2 == 0) {
+						if (num889 > 0 && num889 < Main.maxNPCs && timeLeft % 2 == 0) {
 							Vector2 position8 = center11 - base.velocity.SafeNormalize(Vector2.Zero) * 8f;
 							Vector2 value62 = Main.npc[num889].velocity + new Vector2(Main.rand.NextFloatDirection() * 0.35f, 2.5f);
 							Dust dust42 = Dust.NewDustPerfect(position8, 4, value62, 0, new Color(120, 50, 120), 0.65f);
@@ -24431,7 +_,7 @@
 							bool flag49 = false;
 							int num916 = 0;
 							if (this.ai[1] == 0f) {
-								for (int num917 = 0; num917 < 200; num917++) {
+								for (int num917 = 0; num917 < Main.maxNPCs; num917++) {
 									if (Main.npc[num917].CanBeChasedBy(this)) {
 										Vector2 center12 = Main.npc[num917].Center;
 										if (Distance(center12) < num915 && Collision.CanHit(new Vector2(base.position.X + (float)(base.width / 2), base.position.Y + (float)(base.height / 2)), 1, 1, Main.npc[num917].position, Main.npc[num917].width, Main.npc[num917].height)) {
@@ -24722,7 +_,7 @@
 					}
 
 					if (num933 < 0) {
-						for (int num936 = 0; num936 < 200; num936++) {
+						for (int num936 = 0; num936 < Main.maxNPCs; num936++) {
 							NPC nPC10 = Main.npc[num936];
 							if (nPC10.CanBeChasedBy(this)) {
 								float num937 = Distance(nPC10.Center);
@@ -25253,7 +_,7 @@
 						for (int num974 = num972 - num971; num974 <= num972 + num971; num974++) {
 							for (int num975 = num973 - num971; num975 <= num973 + num971; num975++) {
 								int num976 = Main.rand.Next(8);
-								if (num976 < 4 && new Vector2(num972 - num974, num973 - num975).Length() < (float)num971 && Main.tile[num974, num975] != null && Main.tile[num974, num975].active() && Main.IsTileSpelunkable(Main.tile[num974, num975])) {
+								if (num976 < 4 && new Vector2(num972 - num974, num973 - num975).Length() < (float)num971 && Main.tile[num974, num975] != null && Main.tile[num974, num975].active() && Main.IsTileSpelunkable(num974, num975)) {
 									float num977 = Distance(new Vector2(num974 * 16 + 8, num975 * 16 + 8));
 									if (num977 < num970 || num970 == -1f) {
 										num970 = num977;
@@ -25293,7 +_,7 @@
 				int num984 = -1;
 				float num985 = 300f;
 				float num986 = 500f;
-				for (int num987 = 0; num987 < 200; num987++) {
+				for (int num987 = 0; num987 < Main.maxNPCs; num987++) {
 					NPC nPC12 = Main.npc[num987];
 					if (!nPC12.active || !nPC12.chaseable || nPC12.dontTakeDamage || nPC12.immortal)
 						continue;
@@ -25809,7 +_,7 @@
 
 					if (localAI[0] == 0f && this.ai[0] < 0f && owner == Main.myPlayer) {
 						localAI[0] = 5f;
-						for (int num1034 = 0; num1034 < 200; num1034++) {
+						for (int num1034 = 0; num1034 < Main.maxNPCs; num1034++) {
 							NPC nPC13 = Main.npc[num1034];
 							if (nPC13.CanBeChasedBy(this)) {
 								bool flag63 = this.ai[0] < 0f || Main.npc[(int)this.ai[0]].Distance(base.Center) > nPC13.Distance(base.Center);
@@ -26028,7 +_,7 @@
 				if (!(this.ai[0] >= 40f))
 					return;
 
-				for (int num1047 = 0; num1047 < 200; num1047++) {
+				for (int num1047 = 0; num1047 < Main.maxNPCs; num1047++) {
 					NPC nPC14 = Main.npc[num1047];
 					if (nPC14.active && nPC14.damage >= 1 && nPC14.lifeMax >= 30 && !(Distance(nPC14.Center) > 1000f) && nPC14.type != 564 && nPC14.type != 565) {
 						int num1048 = 500;
@@ -26382,7 +_,7 @@
 
 			Player player = Main.player[owner];
 			bool flag = false;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (nPC.active && !nPC.townNPC && !nPC.dontTakeDamage && !nPC.friendly && base.Hitbox.Intersects(nPC.Hitbox)) {
 					flag = true;
@@ -26401,7 +_,7 @@
 			}
 
 			if (flag) {
-				player.CheckMana(player.inventory[player.selectedItem].mana, pay: true);
+				player.CheckMana(player.inventory[player.selectedItem], pay: true);
 				localAI[0] = 1f;
 			}
 		}
@@ -26606,7 +_,7 @@
 					}
 
 					if (num6 < 0) {
-						for (int i = 0; i < 200; i++) {
+						for (int i = 0; i < Main.maxNPCs; i++) {
 							NPC nPC = Main.npc[i];
 							if (nPC.CanBeChasedBy(this) && player.Distance(nPC.Center) < num5) {
 								float num8 = Distance(nPC.Center);
@@ -27325,8 +_,8 @@
 				wetVelocity = base.velocity;
 		}
 
-		private void ResetLocalNPCHitImmunity() {
+		public void ResetLocalNPCHitImmunity() {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				localNPCImmunity[i] = 0;
 			}
 		}
@@ -27419,8 +_,7 @@
 					break;
 			}
 
-			float meleeSpeed = player.meleeSpeed;
-			float num15 = 1f / meleeSpeed;
+			float num15 = 1f / player.inverseMeleeSpeed;
 			num2 *= num15;
 			num8 *= num15;
 			num9 *= num15;
@@ -27610,7 +_,7 @@
 					localAI[0] += 1f;
 					if (localAI[0] >= 20f) {
 						localAI[0] = 17f;
-						for (int i = 0; i < 200; i++) {
+						for (int i = 0; i < Main.maxNPCs; i++) {
 							NPC nPC2 = Main.npc[i];
 							if (nPC2.CanBeChasedBy(this)) {
 								float num21 = Distance(nPC2.Center);
@@ -27733,7 +_,7 @@
 				}
 			}
 			else if (ai[0] == 1f) {
-				float meleeSpeed = Main.player[owner].meleeSpeed;
+				float meleeSpeed = Main.player[owner].inverseMeleeSpeed;
 				float num5 = 14f / meleeSpeed;
 				float num6 = 0.9f / meleeSpeed;
 				float num7 = 300f / meleeSpeed;
@@ -27817,7 +_,7 @@
 					localAI[1] += 1f;
 					if (localAI[1] > 20f) {
 						localAI[1] = 20f;
-						for (int i = 0; i < 200; i++) {
+						for (int i = 0; i < Main.maxNPCs; i++) {
 							if (Main.npc[i].CanBeChasedBy(this)) {
 								float num15 = Main.npc[i].position.X + (float)(Main.npc[i].width / 2);
 								float num16 = Main.npc[i].position.Y + (float)(Main.npc[i].height / 2);
@@ -27967,7 +_,7 @@
 
 					if (!flag2 || ai[0] % 15f == 0f) {
 						bool flag3 = false;
-						for (int i = 0; i < 200; i++) {
+						for (int i = 0; i < Main.maxNPCs; i++) {
 							NPC nPC = Main.npc[i];
 							if (nPC.active && Distance(nPC.Center) < 320f && nPC.CanBeChasedBy(this) && Collision.CanHitLine(nPC.position, nPC.width, nPC.height, position, 0, 0)) {
 								flag3 = true;
@@ -27977,13 +_,13 @@
 
 						if (flag3) {
 							bool flag4 = false;
-							if (!flag || player.CheckMana(player.inventory[player.selectedItem].mana, pay: true)) {
+							if (!flag || player.CheckMana(player.inventory[player.selectedItem], pay: true)) {
 								int num = damage;
 								position = base.Center;
 								int num2 = 0;
 								float num3 = 0f;
 								_medusaHeadTargetList.Clear();
-								for (int j = 0; j < 200; j++) {
+								for (int j = 0; j < Main.maxNPCs; j++) {
 									NPC nPC2 = Main.npc[j];
 									float num4 = Distance(nPC2.Center);
 									if (nPC2.active && num4 < 320f && nPC2.CanBeChasedBy(this) && Collision.CanHitLine(nPC2.position, nPC2.width, nPC2.height, position, 0, 0))
@@ -28312,7 +_,7 @@
 
 		private void AI_120_StardustGuardian_FindTarget(float lookupRange, ref int targetNPCIndex, ref float distanceToClosestTarget) {
 			Vector2 center = Main.player[owner].Center;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (nPC.CanBeChasedBy(this)) {
 					float num = center.Distance(nPC.Center);
@@ -28429,7 +_,7 @@
 		public NPC FindTargetWithinRange(float maxRange, bool checkCanHit = false) {
 			NPC result = null;
 			float num = maxRange;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (nPC.CanBeChasedBy(this) && localNPCImmunity[i] == 0 && (!checkCanHit || Collision.CanHitLine(position, width, height, nPC.position, nPC.width, nPC.height))) {
 					float num2 = Distance(nPC.Center);
@@ -28874,10 +_,18 @@
 			return result;
 		}
 
+		/// <summary>
+		/// Finds the closest NPC to this projectile which can be targeted and which it has line of sight to.
+		/// </summary>
+		/// <param name="maxRange">
+		/// The maximum range at which this projectile should search out a target, measured in pixels.<br/>
+		/// Defaults to 800 (50 tiles). Each tile, for reference, measures out to be 16x16 pixels.
+		/// </param>
+		/// <returns>The index, in <see cref="Main.npc"/>, of the closest targetable NPC.</returns>
 		public int FindTargetWithLineOfSight(float maxRange = 800f) {
 			float num = maxRange;
 			int result = -1;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				bool flag = nPC.CanBeChasedBy(this);
 				if (localNPCImmunity[i] != 0)
@@ -29210,7 +_,7 @@
 			if (flag2 && player.channel && player.itemAnimation < num)
 				player.SetDummyItemTime(num);
 
-			if (player.itemAnimation == 0)
+			if (player.ItemAnimationEndingOrEnded)
 				Kill();
 
 			rotation = (float)Math.Atan2(velocity.Y, velocity.X) + (float)Math.PI / 2f + (float)Math.PI / 4f;
@@ -29480,7 +_,7 @@
 				ai[1] += 1f;
 			}
 
-			if (Main.player[owner].itemAnimation == 0)
+			if (Main.player[owner].ItemAnimationEndingOrEnded)
 				Kill();
 
 			rotation = (float)Math.Atan2(velocity.Y, velocity.X) + 2.355f;
@@ -30084,7 +_,7 @@
 					ai[0] += 1f;
 					if (ai[0] > 30f) {
 						ai[0] = 30f;
-						for (int m = 0; m < 200; m++) {
+						for (int m = 0; m < Main.maxNPCs; m++) {
 							if (Main.npc[m].CanBeChasedBy(this)) {
 								float num19 = Main.npc[m].position.X + (float)(Main.npc[m].width / 2);
 								float num20 = Main.npc[m].position.Y + (float)(Main.npc[m].height / 2);
@@ -30381,8 +_,11 @@
 			}
 
 			player.heldProj = whoAmI;
+
+			// causes projectile to be duped with #2351 because tML makes reuse start at itemAnimation == 1
+			// could fix the calculation to `player.itemAnimationMax - (int)((ai[0] - 1) / MaxUpdates);` but the code doesn't do anything useful (even in vanilla)
-			player.itemAnimation = player.itemAnimationMax - (int)(ai[0] / (float)MaxUpdates);
+			// player.itemAnimation = player.itemAnimationMax - (int)(ai[0] / MaxUpdates);
-			player.itemTime = player.itemAnimation;
+			// player.itemTime = player.itemAnimation;
 			if (ai[0] == (float)(int)(timeToFlyOut / 2f)) {
 				WhipPointsForCollision.Clear();
 				FillWhipControlPoints(this, WhipPointsForCollision);
@@ -30632,6 +_,11 @@
 
 		public static void GetWhipSettings(Projectile proj, out float timeToFlyOut, out int segments, out float rangeMultiplier) {
 			timeToFlyOut = Main.player[proj.owner].itemAnimationMax * proj.MaxUpdates;
+			segments = proj.WhipSettings.Segments;
+			rangeMultiplier = proj.WhipSettings.RangeMultiplier;
+		}
+
+		private static void VanillaWhipSettings(Projectile proj, out int segments, out float rangeMultiplier) {
 			segments = 20;
 			rangeMultiplier = 1f;
 			switch (proj.type) {
@@ -31091,7 +_,7 @@
 				if (attackTarget >= 0)
 					return;
 
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					NPC nPC = Main.npc[i];
 					if (nPC.CanBeChasedBy(this) && IsInRangeOfMeOrMyOwner(nPC, num, out float myDistance2, out float playerDistance2, out bool closerIsMe2) && (!skipIfCannotHitWithOwnBody || CanHitWithOwnBody(nPC)) && (customEliminationCheck == null || customEliminationCheck(nPC, attackTarget))) {
 						attackTarget = i;
@@ -31115,7 +_,7 @@
 			Vector2 center = Main.player[owner].Center;
 			Rectangle value = Utils.CenteredRectangle(center, new Vector2(1600f, 800f));
 			int num = Main.player[owner].ownedProjectileCounts[831] + 1;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (nPC.CanBeChasedBy(this) && nPC.Hitbox.Intersects(value))
 					list.Add(nPC);
@@ -32579,7 +_,7 @@
 					return ownerMinionAttackTargetNPC.whoAmI;
 			}
 
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (nPC.CanBeChasedBy(this) && (nPC.boss || !blackListedTargets.Contains(i))) {
 					float num2 = nPC.Distance(center);
@@ -33091,6 +_,9 @@
 					if (num3 > (float)num9)
 						ai[0] = 1f;
 				}
+				else if (ProjectileLoader.GrappleOutOfRange(num3, this)) {
+					ai[0] = 1f;
+				}
 
 				Vector2 value = base.Center - new Vector2(5f);
 				Vector2 value2 = base.Center + new Vector2(5f);
@@ -33183,6 +_,7 @@
 							if (type >= 646 && type <= 649)
 								num17 = 4;
 
+							ProjectileLoader.NumGrappleHooks(this, Main.player[owner], ref num17);
 							for (int num18 = 0; num18 < 1000; num18++) {
 								if (Main.projectile[num18].active && Main.projectile[num18].owner == owner && Main.projectile[num18].aiStyle == 7) {
 									if (Main.projectile[num18].timeLeft < num16) {
@@ -33260,6 +_,7 @@
 				if (type == 332)
 					num19 = 17f;
 
+				ProjectileLoader.GrappleRetreatSpeed(this, Main.player[owner], ref num19);
 				if (num3 < 24f)
 					Kill();
 
@@ -33380,7 +_,7 @@
 						bool flag = false;
 						int num12 = 0;
 						if (ai[num3] == 0f) {
-							for (int i = 0; i < 200; i++) {
+							for (int i = 0; i < Main.maxNPCs; i++) {
 								if (Main.npc[i].CanBeChasedBy(this) && (ai[num3] == 0f || ai[num3] == (float)(i + 1))) {
 									float num13 = Main.npc[i].position.X + (float)(Main.npc[i].width / 2);
 									float num14 = Main.npc[i].position.Y + (float)(Main.npc[i].height / 2);
@@ -33470,7 +_,7 @@
 				return;
 			}
 
-			ai[0] += Main.dayRate;
+			ai[0] += (float)Main.desiredWorldEventsUpdateRate;
 			if (localAI[0] == 0f && Main.netMode != 2) {
 				localAI[0] = 1f;
 				if ((double)Main.LocalPlayer.position.Y < Main.worldSurface * 16.0)
@@ -33776,7 +_,7 @@
 						if (tileSafely2.active() && Main.tileSolid[tileSafely2.type] && !Main.tileSolidTop[tileSafely2.type])
 							continue;
 
-						int num4 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely);
+						int num4 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely, j, k);
 						for (int l = 0; l < num4; l++) {
 							Dust obj = Main.dust[WorldGen.KillTile_MakeTileDust(j, k, tileSafely)];
 							obj.velocity.Y -= 3f + (float)num3 * 1.5f;
@@ -34189,6 +_,8 @@
 				int num4 = item.stack = Main.rand.Next(minValue2, num3 + 1);
 			}
 
+			PlayerLoader.ModifyCaughtFish(thePlayer, item);
+			ItemLoader.CaughtFishStack(item);
 			item.newAndShiny = true;
 			Item item2 = thePlayer.GetItem(owner, item, default(GetItemSettings));
 			if (item2.stack > 0) {
@@ -34604,7 +_,7 @@
 				else if (ai[1] == 1f && owner == Main.myPlayer) {
 					int num35 = -1;
 					float num36 = num29;
-					for (int num37 = 0; num37 < 200; num37++) {
+					for (int num37 = 0; num37 < Main.maxNPCs; num37++) {
 						if (Main.npc[num37].active && Main.npc[num37].CanBeChasedBy(this)) {
 							Vector2 center3 = Main.npc[num37].Center;
 							float num38 = Vector2.Distance(center3, base.Center);
@@ -35766,7 +_,7 @@
 				Rectangle hitbox = base.Hitbox;
 				hitbox.Offset((int)base.velocity.X, (int)base.velocity.Y);
 				bool flag2 = false;
-				for (int num126 = 0; num126 < 200; num126++) {
+				for (int num126 = 0; num126 < Main.maxNPCs; num126++) {
 					NPC nPC = Main.npc[num126];
 					if (nPC.active && !nPC.dontTakeDamage && nPC.immune[owner] == 0 && localNPCImmunity[num126] == 0 && nPC.Hitbox.Intersects(hitbox) && !nPC.friendly) {
 						flag2 = true;
@@ -36492,7 +_,7 @@
 				bool flag4 = false;
 				int num185 = 0;
 				if (ai[1] == 0f) {
-					for (int num186 = 0; num186 < 200; num186++) {
+					for (int num186 = 0; num186 < Main.maxNPCs; num186++) {
 						if (Main.npc[num186].CanBeChasedBy(this) && (ai[1] == 0f || ai[1] == (float)(num186 + 1))) {
 							float num187 = Main.npc[num186].position.X + (float)(Main.npc[num186].width / 2);
 							float num188 = Main.npc[num186].position.Y + (float)(Main.npc[num186].height / 2);
@@ -36641,7 +_,7 @@
 				if (numUpdates == 0) {
 					int num202 = -1;
 					float num203 = 60f;
-					for (int num204 = 0; num204 < 200; num204++) {
+					for (int num204 = 0; num204 < Main.maxNPCs; num204++) {
 						NPC nPC2 = Main.npc[num204];
 						if (nPC2.CanBeChasedBy(this)) {
 							float num205 = Distance(nPC2.Center);
@@ -36919,7 +_,7 @@
 					if (ai[0] > 20f) {
 						ai[0] -= 1f;
 						if (ai[1] == 0f) {
-							for (int num224 = 0; num224 < 200; num224++) {
+							for (int num224 = 0; num224 < Main.maxNPCs; num224++) {
 								if (Main.npc[num224].CanBeChasedBy(this) && (ai[1] == 0f || ai[1] == (float)(num224 + 1))) {
 									float num225 = Main.npc[num224].position.X + (float)(Main.npc[num224].width / 2);
 									float num226 = Main.npc[num224].position.Y + (float)(Main.npc[num224].height / 2);
@@ -38947,7 +_,7 @@
 
 					bool flag11 = false;
 					int num86 = -1;
-					for (int num87 = 0; num87 < 200; num87++) {
+					for (int num87 = 0; num87 < Main.maxNPCs; num87++) {
 						if (!Main.npc[num87].CanBeChasedBy(this))
 							continue;
 
@@ -39812,7 +_,7 @@
 						}
 
 						if (num119 == -1) {
-							for (int num123 = 0; num123 < 200; num123++) {
+							for (int num123 = 0; num123 < Main.maxNPCs; num123++) {
 								if (!Main.npc[num123].CanBeChasedBy(this))
 									continue;
 
@@ -39935,7 +_,7 @@
 						}
 
 						if (num143 == -1) {
-							for (int num145 = 0; num145 < 200; num145++) {
+							for (int num145 = 0; num145 < Main.maxNPCs; num145++) {
 								if (!Main.npc[num145].CanBeChasedBy(this))
 									continue;
 
@@ -42458,7 +_,7 @@
 				}
 
 				if (!flag) {
-					for (int n = 0; n < 200; n++) {
+					for (int n = 0; n < Main.maxNPCs; n++) {
 						NPC nPC = Main.npc[n];
 						if (nPC.CanBeChasedBy(this)) {
 							Vector2 vector3 = nPC.position + nPC.Size * value;
@@ -42490,7 +_,7 @@
 				}
 
 				if (!flag) {
-					for (int num19 = 0; num19 < 200; num19++) {
+					for (int num19 = 0; num19 < Main.maxNPCs; num19++) {
 						NPC nPC2 = Main.npc[num19];
 						if (!nPC2.CanBeChasedBy(this))
 							continue;
@@ -43119,7 +_,7 @@
 				}
 
 				if (flag && Main.myPlayer == owner) {
-					if (player.channel && player.CheckMana(player.inventory[player.selectedItem].mana, pay: true) && !player.noItems && !player.CCed) {
+					if (player.channel && player.CheckMana(player.inventory[player.selectedItem], pay: true) && !player.noItems && !player.CCed) {
 						float num8 = player.inventory[player.selectedItem].shootSpeed * scale;
 						Vector2 value2 = vector;
 						Vector2 value3 = Main.screenPosition + new Vector2(Main.mouseX, Main.mouseY) - value2;
@@ -43356,7 +_,7 @@
 
 				if (flag5 && Main.myPlayer == owner) {
 					bool flag6 = false;
-					flag6 = (!flag3 || player.CheckMana(player.inventory[player.selectedItem].mana, pay: true));
+					flag6 = (!flag3 || player.CheckMana(player.inventory[player.selectedItem], pay: true));
 					if (player.channel && flag6 && !player.noItems && !player.CCed) {
 						if (ai[0] == 180f) {
 							Vector2 center = base.Center;
@@ -43416,7 +_,7 @@
 				if (ai[0] > 120f)
 					num35 = 5f;
 
-				damage = (int)((float)player.inventory[player.selectedItem].damage * player.magicDamage);
+				damage = (int)player.GetTotalDamage(DamageClass.Magic).ApplyTo(player.inventory[player.selectedItem].damage);
 				ai[0] += 1f;
 				ai[1] += 1f;
 				bool flag8 = false;
@@ -43468,7 +_,7 @@
 
 				if (flag9 && Main.myPlayer == owner) {
 					bool flag10 = false;
-					flag10 = (!flag8 || player.CheckMana(player.inventory[player.selectedItem].mana, pay: true));
+					flag10 = (!flag8 || player.CheckMana(player.inventory[player.selectedItem], pay: true));
 					if (player.channel && flag10 && !player.noItems && !player.CCed) {
 						if (ai[0] == 1f) {
 							Vector2 center2 = base.Center;
@@ -44293,7 +_,7 @@
 					if (type == 603)
 						num6 = 320f;
 
-					for (int j = 0; j < 200; j++) {
+					for (int j = 0; j < Main.maxNPCs; j++) {
 						if (Main.npc[j].CanBeChasedBy(this)) {
 							float num7 = Main.npc[j].position.X + (float)(Main.npc[j].width / 2);
 							float num8 = Main.npc[j].position.Y + (float)(Main.npc[j].height / 2);
@@ -44386,7 +_,7 @@
 					localAI[0] += (float)Main.rand.Next(10, 31) * 0.1f;
 
 				float num = localAI[0] / 60f;
-				num /= (1f + Main.player[owner].meleeSpeed) / 2f;
+				num /= (1f + Main.player[owner].inverseMeleeSpeed) / 2f;
 				float num2 = ProjectileID.Sets.YoyosLifeTimeMultiplier[type];
 				if (num2 != -1f && num > num2)
 					ai[0] = -1f;
@@ -44405,7 +_,7 @@
 
 					velocity *= 0.25f;
 					velocity += vector;
-					for (int j = 0; j < 200; j++) {
+					for (int j = 0; j < Main.maxNPCs; j++) {
 						if (Main.npc[j].CanBeChasedBy(this)) {
 							float num4 = Main.npc[j].position.X + (float)(Main.npc[j].width / 2);
 							float num5 = Main.npc[j].position.Y + (float)(Main.npc[j].height / 2);
@@ -44474,12 +_,17 @@
 			if (Main.player[owner].yoyoString)
 				num10 = num10 * 1.25f + 30f;
 
-			num10 /= (1f + Main.player[owner].meleeSpeed * 3f) / 4f;
+			num10 /= (1f + Main.player[owner].inverseMeleeSpeed * 3f) / 4f;
-			num8 /= (1f + Main.player[owner].meleeSpeed * 3f) / 4f;
+			num8 /= (1f + Main.player[owner].inverseMeleeSpeed * 3f) / 4f;
 			num7 = 14f - num8 / 2f;
 			if (num7 < 1f)
 				num7 = 1f;
 
+			// Yoyos with effective top speed (boosted by melee speed) num8 > 26 will set num11 to be less than 1.
+			// This breaks the AI's acceleration vector math and stops the velocity from being correctly capped every frame.
+			// Providing a minimum value of 1.01 to num11 fixes this, allowing for very fast modded yoyos.
+			// See issue #751 for more details.
+			if (num7 < 1.01f) num7 = 1.01f;
 			num9 = 5f + num8 / 2f;
 			if (flag)
 				num9 += 20f;
@@ -44830,7 +_,7 @@
 					return num;
 			}
 
-			for (int j = 0; j < 200; j++) {
+			for (int j = 0; j < Main.maxNPCs; j++) {
 				NPC nPC = Main.npc[j];
 				if (!nPC.CanBeChasedBy(this))
 					continue;
@@ -44866,7 +_,7 @@
 					return num;
 			}
 
-			for (int j = 0; j < 200; j++) {
+			for (int j = 0; j < Main.maxNPCs; j++) {
 				NPC nPC = Main.npc[j];
 				if (!nPC.CanBeChasedBy(this))
 					continue;
@@ -45060,7 +_,7 @@
 					if (tileSafely2.active() && Main.tileSolid[tileSafely2.type] && !Main.tileSolidTop[tileSafely2.type])
 						continue;
 
-					int num5 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely);
+					int num5 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely, i, j);
 					for (int k = 0; k < num5; k++) {
 						Dust obj = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 						obj.velocity.Y -= 3f + (float)num4 * 1.5f;
@@ -45205,7 +_,7 @@
 
 			if (ai[0] == 0f) {
 				bool flag = false;
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					NPC nPC = Main.npc[i];
 					if (nPC.CanBeChasedBy(this) && nPC.Hitbox.Distance(base.Center) < (float)(width / 2) && Colliding(base.Hitbox, nPC.Hitbox)) {
 						flag = true;
@@ -45346,7 +_,7 @@
 				localAI[0] = 3f;
 				bool flag = false;
 				Rectangle rectangle = Utils.CenteredRectangle(base.Center + new Vector2(0f, -num3), new Vector2(num3 * 3));
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					NPC nPC = Main.npc[i];
 					if (nPC.CanBeChasedBy(this) && rectangle.Intersects(nPC.Hitbox)) {
 						flag = true;
@@ -45576,7 +_,7 @@
 			}
 		}
 
-		private void CreateImpactExplosion(int dustAmountMultiplier, Vector2 explosionOrigin, ref Point scanAreaStart, ref Point scanAreaEnd, int explosionRange, out bool causedShockwaves) {
+		public void CreateImpactExplosion(int dustAmountMultiplier, Vector2 explosionOrigin, ref Point scanAreaStart, ref Point scanAreaEnd, int explosionRange, out bool causedShockwaves) {
 			causedShockwaves = false;
 			int num = 4;
 			for (int i = scanAreaStart.X; i <= scanAreaEnd.X; i++) {
@@ -45592,7 +_,7 @@
 					if (tileSafely2.active() && Main.tileSolid[tileSafely2.type] && !Main.tileSolidTop[tileSafely2.type])
 						continue;
 
-					int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely) * dustAmountMultiplier;
+					int num2 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely, i, j) * dustAmountMultiplier;
 					for (int k = 0; k < num2; k++) {
 						Dust obj = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 						obj.velocity.Y -= 3f + (float)num * 1.5f;
@@ -45648,7 +_,7 @@
 			}
 		}
 
-		private void CreateImpactExplosion2_FlailTileCollision(Vector2 explosionOrigin, bool causedShockwaves, Vector2 velocityBeforeCollision) {
+		public void CreateImpactExplosion2_FlailTileCollision(Vector2 explosionOrigin, bool causedShockwaves, Vector2 velocityBeforeCollision) {
 			Vector2 spinningpoint = new Vector2(7f, 0f);
 			Vector2 value = new Vector2(1f, 0.7f);
 			Color color = Color.White * 0.5f;
@@ -46241,6 +_,11 @@
 			int num = timeLeft;
 			timeLeft = 0;
 			ParticleOrchestraSettings settings;
+			if (!ProjectileLoader.PreKill(this, num)) {
+				active = false;
+				return;
+			}
+
 			if (type == 949) {
 				SoundEngine.PlaySound(SoundID.Item10, base.Center);
 				int num2 = (int)ai[0];
@@ -47071,7 +_,7 @@
 
 			if (Main.myPlayer == owner && bobber) {
 				PopupText.ClearSonarText();
-				if (ai[1] > 0f && ai[1] < 5125f)
+				if (ai[1] > 0f)
 					AI_061_FishingBobber_GiveItemToPlayer(Main.player[owner], (int)ai[1]);
 
 				ai[1] = 0f;
@@ -48214,7 +_,7 @@
 					int num281 = Main.rand.Next(4, 8);
 					int[] array = new int[num281];
 					int num282 = 0;
-					for (int num283 = 0; num283 < 200; num283++) {
+					for (int num283 = 0; num283 < Main.maxNPCs; num283++) {
 						if (!Main.npc[num283].CanBeChasedBy(this, ignoreDontTakeDamage: true))
 							continue;
 
@@ -52339,7 +_,7 @@
 						player3.AddBuff(num962, 1800, quiet: false);
 				}
 
-				for (int num964 = 0; num964 < 200; num964++) {
+				for (int num964 = 0; num964 < Main.maxNPCs; num964++) {
 					NPC nPC = Main.npc[num964];
 					if (nPC.active && nPC.life > 0 && Vector2.Distance(base.Center, nPC.Center) < num961)
 						nPC.AddBuff(num962, 1800);
@@ -52666,6 +_,7 @@
 				}
 			}
 
+			ProjectileLoader.Kill(this, num);
 			active = false;
 		}
 
@@ -52732,6 +_,9 @@
 			if (Main.tileDungeon[Main.tile[x, y].type] || TileID.Sets.BasicChest[Main.tile[x, y].type])
 				return false;
 
+			if (!TileLoader.CanExplode(x, y))
+				return false;
+
 			switch (Main.tile[x, y].type) {
 				case 26:
 				case 88:
@@ -52792,7 +_,7 @@
 
 					for (int k = i - 1; k <= i + 1; k++) {
 						for (int l = j - 1; l <= j + 1; l++) {
-							if (Main.tile[k, l] != null && Main.tile[k, l].wall > 0 && wallSplode) {
+							if (Main.tile[k, l] != null && Main.tile[k, l].wall > 0 && wallSplode && WallLoader.CanExplode(k, l, Main.tile[k, l].wall)) {
 								WorldGen.KillWall(k, l);
 								if (Main.tile[k, l].wall == 0 && Main.netMode != 0)
 									NetMessage.SendData(17, -1, -1, null, 2, k, l);
@@ -52846,6 +_,10 @@
 		}
 
 		public Color GetAlpha(Color newColor) {
+			Color? modColor = ProjectileLoader.GetAlpha(this, newColor);
+			if (modColor.HasValue)
+				return modColor.Value;
+
 			if (type == 937)
 				newColor.A = (byte)((float)(int)newColor.A * 0.75f);
 
