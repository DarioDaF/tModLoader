--- src/TerrariaNetCore/Terraria/NPC.cs
+++ src/tModLoader/Terraria/NPC.cs
@@ -22,10 +_,11 @@
 using Terraria.Localization;
 using Terraria.Utilities;
 using Terraria.WorldBuilding;
+using Terraria.ModLoader;
 
 namespace Terraria
 {
-	public class NPC : Entity
+	public partial class NPC : Entity
 	{
 		private const int NPC_TARGETS_START = 300;
 		public bool IsABestiaryIconDummy;
@@ -58,7 +_,12 @@
 		public int altTexture;
 		public int townNpcVariationIndex;
 		public Vector2 netOffset = Vector2.Zero;
-		public short catchItem;
+		/// <summary>
+		/// The numerical ID of the item that this NPC becomes when caught.<br></br>
+		/// Mainly used for critters that can be caught with bug nets, such as butterflies and worms.<br></br>
+		/// Bug nets and other catching tools will only work on NPCs with this field set to something greater than 0.
+		/// </summary>
+		public int catchItem; // tML: changed to int for convenience and consistency purposes
 		public short releaseOwner = 255;
 		public int rarity;
 		public static bool taxCollector = false;
@@ -90,6 +_,10 @@
 		public static int crimsonBoss = -1;
 		public int netSkip;
 		public bool netAlways;
+		/// <summary>
+		/// Stores the index of a single NPC. This NPC will then share a health pool with that NPC.<br/>
+		/// Used for the Destroyer's various segments and the Wall of Flesh's eyes and mouth.<br/>
+		/// </summary>
 		public int realLife = -1;
 		private string _givenName = "";
 		public static int sWidth = 1920;
@@ -104,14 +_,14 @@
 		private static int townRangeY = sHeight;
 		public float npcSlots = 1f;
 		private static bool noSpawnCycle = false;
-		private static int activeTime = 750;
+		public static int activeTime = 750;
 		private static int defaultSpawnRate = 600;
 		private static int defaultMaxSpawns = 5;
 		public bool dontCountMe;
 		public const int maxBuffs = 5;
 		public int[] buffType = new int[5];
 		public int[] buffTime = new int[5];
-		public bool[] buffImmune = new bool[338];
+		public bool[] buffImmune = new bool[BuffLoader.BuffCount];
 		public bool midas;
 		public bool ichor;
 		public bool onFire;
@@ -153,33 +_,119 @@
 		public static bool boughtCat = false;
 		public static bool boughtDog = false;
 		public static bool boughtBunny = false;
+		/// <summary>
+		/// Denotes whether or not Advanced Combat Techniques has been used in the current world.
+		/// </summary>
 		public static bool combatBookWasUsed = false;
+		/// <summary>
+		/// Denotes whether or not the Eye of Cthulhu has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedBoss1 = false;
+		/// <summary>
+		/// Denotes whether or not the Eater of Worlds OR the Brain of Cthulhu have been defeated at least once in the current world.<br/>
+		/// This does NOT track the two of them separately; you will need to establish your own fields in a <see cref="ModSystem"/> for that.<br/>
+		/// </summary>
 		public static bool downedBoss2 = false;
+		/// <summary>
+		/// Denotes whether or not Skeletron has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedBoss3 = false;
+		/// <summary>
+		/// Denotes whether or not at least one Queen Bee has been defeated in the current world.
+		/// </summary>
 		public static bool downedQueenBee = false;
+		/// <summary>
+		/// Denotes whether or not King Slime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedSlimeKing = false;
+		/// <summary>
+		/// Denotes whether or not at least one Goblin Army has been defeated in the current world.
+		/// </summary>
 		public static bool downedGoblins = false;
+		/// <summary>
+		/// Denotes whether or not the Frost Legion has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedFrost = false;
+		/// <summary>
+		/// Denotes whether or not at least one Pirate Invasion has been defeated in the current world.
+		/// </summary>
 		public static bool downedPirates = false;
+		/// <summary>
+		/// Denotes whether or not at least one Clown has been killed in the current world.<br/>
+		/// Only used to make the Clothier sell the Clown set once at least one has been killed.
+		/// </summary>
 		public static bool downedClown = false;
+		/// <summary>
+		/// Denotes whether or not Plantera has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedPlantBoss = false;
+		/// <summary>
+		/// Denotes whether or not Golem has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedGolemBoss = false;
+		/// <summary>
+		/// Denotes whether or not at least one Martian Madness event has been cleared in the current world.
+		/// </summary>
 		public static bool downedMartians = false;
+		/// <summary>
+		/// Denotes whether or not Duke Fishron has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedFishron = false;
+		/// <summary>
+		/// Denotes whether or not at least one Mourning Wood has been defeated in the current world.
+		/// </summary>
 		public static bool downedHalloweenTree = false;
+		/// <summary>
+		/// Denotes whether or not at least one Pumpking has been defeated in the current world.
+		/// </summary>
 		public static bool downedHalloweenKing = false;
+		/// <summary>
+		/// Denotes whether or not at least one Ice Queen has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasIceQueen = false;
+		/// <summary>
+		/// Denotes whether or not at least one Everscream has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasTree = false;
+		/// <summary>
+		/// Denotes whether or not at least one Santa-NK1 has been defeated in the current world.
+		/// </summary>
 		public static bool downedChristmasSantank = false;
+		/// <summary>
+		/// Denotes whether or not the Lunatic Cultist has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedAncientCultist = false;
+		/// <summary>
+		/// Denotes whether or not the Moon Lord has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMoonlord = false;
+		/// <summary>
+		/// Denotes whether or not the Solar Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerSolar = false;
+		/// <summary>
+		/// Denotes whether or not the Vortex Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerVortex = false;
+		/// <summary>
+		/// Denotes whether or not the Nebula Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerNebula = false;
+		/// <summary>
+		/// Denotes whether or not the Stardust Pillar has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedTowerStardust = false;
+		/// <summary>
+		/// Denotes whether or not the Empress of Light has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedEmpressOfLight = false;
+		/// <summary>
+		/// Denotes whether or not Queen Slime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedQueenSlime = false;
+		/// <summary>
+		/// Denotes whether or not the Deerclops has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedDeerclops = false;
 		public static int ShieldStrengthTowerSolar = 0;
 		public static int ShieldStrengthTowerVortex = 0;
@@ -192,12 +_,24 @@
 		public static bool TowerActiveNebula = false;
 		public static bool TowerActiveStardust = false;
 		public static bool LunarApocalypseIsUp = false;
+		/// <summary>
+		/// Denotes whether or not ANY Mechanical Boss has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBossAny = false;
+		/// <summary>
+		/// Denotes whether or not the Destroyer has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss1 = false;
+		/// <summary>
+		/// Denotes whether or not the Twins have been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss2 = false;
+		/// <summary>
+		/// Denotes whether or not Skeletron Prime has been defeated at least once in the current world.
+		/// </summary>
 		public static bool downedMechBoss3 = false;
 		public static bool[] npcsFoundForCheckActive = new bool[670];
-		public static int[] lazyNPCOwnedProjectileSearchArray = new int[200];
+		public static int[] lazyNPCOwnedProjectileSearchArray = new int[Main.maxNPCs];
 		private static int spawnRate = defaultSpawnRate;
 		private static int maxSpawns = defaultMaxSpawns;
 		public int soundDelay;
@@ -212,14 +_,22 @@
 		public bool justHit;
 		public int timeLeft;
 		public int target = -1;
+		/// <summary>
+		/// The amount of contact damage this NPC deals.<br/>
+		/// Changing this WILL NOT change the amount of damage done by projectiles.<br/>
+		/// </summary>
 		public int damage;
 		public int defense;
 		public int defDamage;
 		public int defDefense;
+		/// <summary>
+		/// Denotes whether or not this NPC counts as dealing cold damage for the purposes of the Warmth Potion.<br/>
+		/// Defaults to false.
+		/// </summary>
 		public bool coldDamage;
 		public bool trapImmune;
-		public LegacySoundStyle HitSound;
-		public LegacySoundStyle DeathSound;
+		public SoundStyle? HitSound;
+		public SoundStyle? DeathSound;
 		public int life;
 		public int lifeMax;
 		public Rectangle targetRect;
@@ -389,8 +_,26 @@
 
 		public int WhoAmIToTargettingIndex => whoAmI + 300;
 
-		public string TypeName => Lang.GetNPCNameValue(netID);
+		/// <summary>
+		/// The TYPE name of this NPC.<br/>
+		/// Type names are the base titles given to any NPC, and are typically shared amongst all instances of an NPC. For example, the Stylist's type name will always be "Stylist".<br/>
+		/// To modify the type name of a specific NPC, make use of the ModifyTypeName hooks in <see cref="GlobalNPC"/> and <see cref="ModLoader.ModNPC"/>, according to your needs.<br/>
+		/// </summary>
+		public string TypeName {
+			get {
+				string typeName = Lang.GetNPCNameValue(netID);
+				NPCLoader.ModifyTypeName(this, ref typeName);
+				return typeName;
+			}
+		}
 
+		/// <summary>
+		/// The FULL name of this NPC.<br/>
+		/// If the NPC doesn't have a given name, this will just return the type name. A Stylist without a given name will always return "Stylist" here.<br/>
+		/// If the NPC does have a given name, this will return the NPC's full name; given name first, then type name.<br/>
+		/// Full name with a given name is given in the format of "X the Y", where X is their given name and Y is their type name.<br/>
+		/// For example, a Stylist might return "Scarlett the Stylist" here; with Scarlett being her given name, and Stylist being her type name.<br/>
+		/// </summary>
 		public string FullName {
 			get {
 				if (!HasGivenName)
@@ -400,8 +_,14 @@
 			}
 		}
 
+		/// <summary>
+		/// Whether or not this NPC has a given name.<br/>
+		/// </summary>
 		public bool HasGivenName => _givenName.Length != 0;
 
+		/// <summary>
+		/// If this NPC has a given name, returns their given name; otherwise, returns their type name.<br/>
+		/// </summary>
 		public string GivenOrTypeName {
 			get {
 				if (!HasGivenName)
@@ -411,6 +_,11 @@
 			}
 		}
 
+		/// <summary>
+		/// The GIVEN name of this NPC. Can be set directly.<br/>
+		/// Given names are unique to each NPC, though two NPCs can have the same given name.<br/>
+		/// Some vanilla examples of given names are Andrew (for the Guide), Yorai (for the Princess), Whitney (for the Steampunker), or Scarlett (for the Stylist).<br/>
+		/// </summary>
 		public string GivenName {
 			get {
 				return _givenName;
@@ -458,7 +_,7 @@
 
 		public bool isLikeATownNPC {
 			get {
-				if (type == 453)
+				if (NPCID.Sets.ActsLikeTownNPC[type])
 					return true;
 
 				return townNPC;
@@ -636,7 +_,7 @@
 		}
 
 		public static string GetFullnameByID(int npcID) {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == npcID)
 					return Main.npc[i].FullName;
 			}
@@ -694,9 +_,9 @@
 		}
 
 		public static void UpdateFoundActiveNPCs() {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
-				if (nPC.active && nPC.type >= 0 && nPC.type < 670)
+				if (nPC.active && nPC.type >= 0 && nPC.type < NPCLoader.NPCCount)
 					npcsFoundForCheckActive[nPC.type] = true;
 			}
 
@@ -809,8 +_,116 @@
 			return false;
 		}
 
-		public static string getNewNPCName(int npcType) => getNewNPCNameInner(npcType);
-
+		public string getNewNPCName() {
+			string NPCNameCategoryKey = null;
+			switch (type) {
+				// TODO: this looks horrible, and I know it does
+				// ideally, there'd exist a better way to do this,
+				// but as of now, I'm not sure what it would be
+				// -thomas
+				case 17:
+					NPCNameCategoryKey = "MerchantNames";
+					break;
+				case 18:
+					NPCNameCategoryKey = "NurseNames";
+					break;
+				case 19:
+					NPCNameCategoryKey = "ArmsDealerNames";
+					break;
+				case 20:
+					NPCNameCategoryKey = "DryadNames";
+					break;
+				case 22:
+					NPCNameCategoryKey = "GuideNames";
+					break;
+				case 38:
+					NPCNameCategoryKey = "DemolitionistNames";
+					break;
+				case 54:
+					NPCNameCategoryKey = "ClothierNames";
+					break;
+				case 107:
+					NPCNameCategoryKey = "GoblinTinkererNames";
+					break;
+				case 108:
+					NPCNameCategoryKey = "WizardNames";
+					break;
+				case 124:
+					NPCNameCategoryKey = "MechanicNames";
+					break;
+				case 160:
+					NPCNameCategoryKey = "TruffleNames";
+					break;
+				case 178:
+					NPCNameCategoryKey = "SteampunkerNames";
+					break;
+				case 207:
+					NPCNameCategoryKey = "DyeTraderNames";
+					break;
+				case 208:
+					NPCNameCategoryKey = "PartyGirlNames";
+					break;
+				case 209:
+					NPCNameCategoryKey = "CyborgNames";
+					break;
+				case 227:
+					NPCNameCategoryKey = "PainterNames";
+					break;
+				case 228:
+					NPCNameCategoryKey = "WitchDoctorNames";
+					break;
+				case 229:
+					NPCNameCategoryKey = "PirateNames";
+					break;
+				case 353:
+					NPCNameCategoryKey = "StylistNames";
+					break;
+				case 368:
+					NPCNameCategoryKey = "TravelingMerchantNames";
+					break;
+				case 369:
+					NPCNameCategoryKey = "AnglerNames";
+					break;
+				case 453:
+					NPCNameCategoryKey = "SkeletonMerchantNames";
+					break;
+				case 441:
+					NPCNameCategoryKey = "TaxCollectorNames";
+					break;
+				case 550:
+					NPCNameCategoryKey = "BartenderNames";
+					break;
+				case 588:
+					NPCNameCategoryKey = "GolferNames";
+					break;
+				case 633:
+					NPCNameCategoryKey = "BestiaryGirlNames";
+					break;
+				case 663:
+					NPCNameCategoryKey = "PrincessNames";
+					break;
+				case 637:
+					NPCNameCategoryKey = "CatNames_Siamese";
+					break;
+				case 638:
+					NPCNameCategoryKey = "DogNames_Labrador";
+					break;
+				case 656:
+					NPCNameCategoryKey = "BunnyNames_White";
+					break;
+			}
+
+			List<string> NPCNameList = new List<string>();
+			if (NPCNameCategoryKey != null)
+				NPCNameList = LanguageManager.Instance.GetLocalizedEntriesInCategory(NPCNameCategoryKey);
+			NPCNameList = NPCLoader.ModifyNPCNameList(this, NPCNameList);
+			if (NPCNameList != null && NPCNameList.Count > 0)
+				return NPCNameList[WorldGen.genRand.Next(NPCNameList.Count)];
+			else
+				return "";
+		}
+
+		/*
 		private static string getNewNPCNameInner(int npcType) {
 			switch (npcType) {
 				case 17:
@@ -874,9 +_,10 @@
 				case 656:
 					return Language.RandomFromCategory("BunnyNames_White", WorldGen.genRand).Value;
 				default:
-					return "";
+					return NPCLoader.TownNPCName(npcType);
 			}
 		}
+		*/
 
 		public NetworkText GetTypeNetName() => NetworkText.FromKey(Lang.GetNPCName(netID).Key);
 
@@ -912,12 +_,12 @@
 
 		public static void setNPCName(string newName, int npcType, bool resetExtras = false) {
 			bool flag = false;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (!Main.npc[i].active || Main.npc[i].type != npcType)
 					continue;
 
 				if (flag) {
-					Main.npc[i].GivenName = getNewNPCName(npcType);
+					Main.npc[i].GivenName = Main.npc[i].getNewNPCName();
 					Main.npc[i].needsUniqueInfoUpdate = true;
 					continue;
 				}
@@ -930,17 +_,19 @@
 			}
 		}
 
+		/*
 		public static string firstNPCName(int npcType) {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == npcType)
 					return Main.npc[i].GivenOrTypeName;
 			}
 
 			return getNewNPCName(npcType);
 		}
+		*/
 
 		public static string GetFirstNPCNameOrNull(int npcType) {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == npcType)
 					return Main.npc[i].GivenOrTypeName;
 			}
@@ -952,7 +_,7 @@
 			int num = 0;
 			int num2 = 0;
 			int num3 = 0;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (!Main.npc[i].active)
 					continue;
 
@@ -1072,7 +_,7 @@
 				case 656:
 					return 39;
 				default:
-					return -1;
+					return NPCHeadLoader.GetNPCHeadSlot(type);
 			}
 		}
 
@@ -1139,7 +_,7 @@
 				case 39:
 					return 656;
 				default:
-					return -1;
+					return NPCHeadLoader.GetNPCFromHeadSlot(headIndex);
 			}
 		}
 
@@ -1172,6 +_,8 @@
 					break;
 			}
 
+			NPCLoader.BossHeadSlot(this, ref result);
+
 			return result;
 		}
 
@@ -1193,6 +_,7 @@
 					break;
 			}
 
+			NPCLoader.BossHeadRotation(this, ref result);
 			return result;
 		}
 
@@ -1201,6 +_,7 @@
 			if (type == 491 && spriteDirection == 1)
 				result = SpriteEffects.FlipHorizontally;
 
+			NPCLoader.BossHeadSpriteEffects(this, ref result);
 			return result;
 		}
 
@@ -1869,9 +_,21 @@
 			defDamage = damage;
 			defDefense = defense;
 			if (flag) {
-				ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData, spawnparams.strengthMultiplierOverride);
+				ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData ?? Main.GameModeInfo, spawnparams.strengthMultiplierOverride);
 				life = lifeMax;
 			}
+		}
+
+		public void CloneDefaults(int Type) {
+			int originalType = type;
+			int originalNetID = netID;
+			var originalModNPC = ModNPC;
+			var originalGlobals = globalNPCs;
+			SetDefaultsKeepPlayerInteraction(Type);
+			type = originalType;
+			netID = originalNetID;
+			ModNPC = originalModNPC;
+			globalNPCs = originalGlobals;
 		}
 
 		public void SetDefaultsKeepPlayerInteraction(int Type) {
@@ -1910,6 +_,9 @@
 				return;
 			}
 
+			ModNPC = null;
+			ShowNameOnHover = true;
+			globalNPCs = new Instanced<GlobalNPC>[0];
 			waterMovementSpeed = (lavaMovementSpeed = 0.5f);
 			honeyMovementSpeed = 0.25f;
 			netOffset *= 0f;
@@ -1954,10 +_,14 @@
 				buffType[k] = 0;
 			}
 
+			if (buffImmune.Length != BuffLoader.BuffCount)
+				Array.Resize(ref buffImmune, BuffLoader.BuffCount);
+
-			for (int l = 0; l < 338; l++) {
+			for (int l = 0; l < buffImmune.Length; l++) {
 				buffImmune[l] = false;
 			}
 
+			aiStyle = type < NPCID.Count ? 0 : -1; //Added by tML - use aiStyle -1 for modded NPCs by default so they don't always face the nearest player, and trigger net updates
 			setFrameSize = false;
 			netSkip = -2;
 			realLife = -1;
@@ -10243,13 +_,18 @@
 				dontTakeDamage = true;
 			}
 
+			NPCLoader.SetDefaults(this);
+
 			if (Main.dedServ)
 				frame = default(Rectangle);
+			// Extra patch context.
 			else if (TextureAssets.Npc[type] != null && TextureAssets.Npc[type].IsLoaded)
 				frame = new Rectangle(0, 0, TextureAssets.Npc[type].Width(), TextureAssets.Npc[type].Height() / Main.npcFrameCount[type]);
 			else
 				setFrameSize = true;
 
+			// Extra patch context.
+
 			if (spawnparams.sizeScaleOverride.HasValue) {
 				int num2 = (int)((float)width * scale);
 				int num3 = (int)((float)height * scale);
@@ -10288,7 +_,7 @@
 			if (Main.tenthAnniversaryWorld)
 				getTenthAnniversaryAdjustments();
 
-			ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData, spawnparams.strengthMultiplierOverride);
+			ScaleStats(spawnparams.playerCountForMultiplayerDifficultyOverride, spawnparams.gameModeData.Value, spawnparams.strengthMultiplierOverride);
 			life = lifeMax;
 		}
 
@@ -10837,6 +_,7 @@
 					break;
 			}
 
+			NPCLoader.ScaleExpertStats(this, numPlayers, balance);
 			defDefense = defense;
 			defDamage = damage;
 			life = lifeMax;
@@ -11001,7 +_,7 @@
 				Vector2 center2 = Main.player[Main.myPlayer].Center;
 				int num7 = (int)Main.npc[i].ai[num2];
 				int num8 = 0;
-				while (num7 >= 0 && num7 < 200 && ++num8 < 100 && Main.npc[num7].active) {
+				while (num7 >= 0 && num7 < Main.maxNPCs && ++num8 < 100 && Main.npc[num7].active) {
 					if (!averageDirection && (num6 == -1 || Main.npc[num7].Distance(center2) < num5)) {
 						num5 = Main.npc[num7].Distance(center2);
 						num6 = num7;
@@ -11049,6 +_,18 @@
 		}
 
 		public void AI() {
+			NPCLoader.NPCAI(this);
+		}
+
+		public void VanillaAI() {
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			VanillaAI_Inner();
+
+			IEntitySource.PopFallback();
+		}
+
+		private void VanillaAI_Inner() {
 			if (aiStyle == 0) {
 				if (Main.netMode != 1) {
 					for (int i = 0; i < 255; i++) {
@@ -11319,7 +_,7 @@
 									int num22 = NewNPC(GetSpawnSourceForNPCFromNPCAI(), (int)position.X, (int)position.Y, 5);
 									Main.npc[num22].velocity.X = vector2.X;
 									Main.npc[num22].velocity.Y = vector2.Y;
-									if (Main.netMode == 2 && num22 < 200)
+									if (Main.netMode == 2 && num22 < Main.maxNPCs)
 										NetMessage.SendData(23, -1, -1, null, num22);
 								}
 
@@ -11441,7 +_,7 @@
 							int num33 = NewNPC(GetSpawnSourceForNPCFromNPCAI(), (int)position2.X, (int)position2.Y, 5);
 							Main.npc[num33].velocity.X = vector5.X;
 							Main.npc[num33].velocity.Y = vector5.Y;
-							if (Main.netMode == 2 && num33 < 200)
+							if (Main.netMode == 2 && num33 < Main.maxNPCs)
 								NetMessage.SendData(23, -1, -1, null, num33);
 						}
 
@@ -12548,7 +_,7 @@
 
 				int num157 = 0;
 				if (Main.expertMode) {
-					for (int num158 = 0; num158 < 200; num158++) {
+					for (int num158 = 0; num158 < Main.maxNPCs; num158++) {
 						if (Main.npc[num158].active && Main.npc[num158].type == type + 1)
 							num157++;
 					}
@@ -13955,7 +_,7 @@
 					Main.npc[num259].velocity.Y = (float)Main.rand.Next(-30, 1) * 0.1f;
 					Main.npc[num259].ai[0] = -1000 * Main.rand.Next(3);
 					Main.npc[num259].ai[1] = 0f;
-					if (Main.netMode == 2 && num259 < 200)
+					if (Main.netMode == 2 && num259 < Main.maxNPCs)
 						NetMessage.SendData(23, -1, -1, null, num259);
 				}
 			}
@@ -15288,7 +_,7 @@
 						netUpdate = true;
 					}
 					else if (this.ai[0] == 1f && Main.cloudAlpha == 0f && !Main.dayTime) {
-						for (int num339 = 0; num339 < 200; num339++) {
+						for (int num339 = 0; num339 < Main.maxNPCs; num339++) {
 							if (num339 == whoAmI || !Main.npc[num339].active)
 								continue;
 
@@ -15759,7 +_,7 @@
 					if (Main.rand.Next(num366) == 0) {
 						int num367 = 0;
 						float[] array = new float[10];
-						for (int num368 = 0; num368 < 200; num368++) {
+						for (int num368 = 0; num368 < Main.maxNPCs; num368++) {
 							if (num367 < 10 && Main.npc[num368].active && Main.npc[num368].type == 115) {
 								array[num367] = Main.npc[num368].ai[0];
 								num367++;
@@ -16160,7 +_,7 @@
 				}
 
 				if (Main.netMode != 1 && !Main.dayTime && !dead2 && timeLeft < 10) {
-					for (int num403 = 0; num403 < 200; num403++) {
+					for (int num403 = 0; num403 < Main.maxNPCs; num403++) {
 						if (num403 != whoAmI && Main.npc[num403].active && (Main.npc[num403].type == 125 || Main.npc[num403].type == 126))
 							DiscourageDespawn(Main.npc[num403].timeLeft - 1);
 					}
@@ -16608,7 +_,7 @@
 				}
 
 				if (Main.netMode != 1 && !Main.dayTime && !dead3 && timeLeft < 10) {
-					for (int num442 = 0; num442 < 200; num442++) {
+					for (int num442 = 0; num442 < Main.maxNPCs; num442++) {
 						if (num442 != whoAmI && Main.npc[num442].active && (Main.npc[num442].type == 125 || Main.npc[num442].type == 126))
 							DiscourageDespawn(Main.npc[num442].timeLeft - 1);
 					}
@@ -19649,7 +_,7 @@
 					num670 = 150f;
 					num672 = Main.player[target].Center.Y - (float)(height / 2);
 					rotation = base.velocity.X * 0.1f;
-					for (int num673 = 0; num673 < 200; num673++) {
+					for (int num673 = 0; num673 < Main.maxNPCs; num673++) {
 						if (num673 != whoAmI && Main.npc[num673].active && Main.npc[num673].type == type && Math.Abs(base.position.X - Main.npc[num673].position.X) + Math.Abs(base.position.Y - Main.npc[num673].position.Y) < (float)width) {
 							if (base.position.X < Main.npc[num673].position.X)
 								base.velocity.X -= 0.05f;
@@ -19672,7 +_,7 @@
 					num670 = 150f;
 					num672 = Main.player[target].Center.Y - (float)(height / 2);
 					rotation = base.velocity.X * 0.1f;
-					for (int num674 = 0; num674 < 200; num674++) {
+					for (int num674 = 0; num674 < Main.maxNPCs; num674++) {
 						if (num674 != whoAmI && Main.npc[num674].active && Main.npc[num674].type == type && Math.Abs(base.position.X - Main.npc[num674].position.X) + Math.Abs(base.position.Y - Main.npc[num674].position.Y) < (float)width) {
 							if (base.position.X < Main.npc[num674].position.X)
 								base.velocity.X -= 0.05f;
@@ -19796,7 +_,7 @@
 				bool flag39 = false;
 				bool flag40 = false;
 				dontTakeDamage = false;
-				for (int num676 = 0; num676 < 200; num676++) {
+				for (int num676 = 0; num676 < Main.maxNPCs; num676++) {
 					if (Main.npc[num676].active && Main.npc[num676].type == 246)
 						flag38 = true;
 
@@ -20303,7 +_,7 @@
 
 					bool flag41 = justHit;
 					if (flag41) {
-						for (int num734 = 0; num734 < 200; num734++) {
+						for (int num734 = 0; num734 < Main.maxNPCs; num734++) {
 							if (!Main.npc[num734].active || Main.npc[num734].type != 246)
 								continue;
 
@@ -20693,7 +_,7 @@
 				float num774 = 0f;
 				float num775 = 0f;
 				int num776 = 0;
-				for (int num777 = 0; num777 < 200; num777++) {
+				for (int num777 = 0; num777 < Main.maxNPCs; num777++) {
 					if (Main.npc[num777].active && Main.npc[num777].aiStyle == 52) {
 						num774 += Main.npc[num777].Center.X;
 						num775 += Main.npc[num777].Center.Y;
@@ -20912,7 +_,7 @@
 						}
 
 						if (Main.expertMode) {
-							for (int num798 = 0; num798 < 200; num798++) {
+							for (int num798 = 0; num798 < Main.maxNPCs; num798++) {
 								if (Main.npc[num798].active && Main.npc[num798].aiStyle == 52) {
 									for (int num799 = 0; num799 < num795 / 2 - 1; num799++) {
 										int num800 = NewNPC(GetSpawnSourceForNPCFromNPCAI(), (int)base.Center.X, (int)base.Center.Y, 264, whoAmI);
@@ -20924,7 +_,7 @@
 					}
 					else if (Main.expertMode && Main.rand.Next(60) == 0) {
 						int num801 = 0;
-						for (int num802 = 0; num802 < 200; num802++) {
+						for (int num802 = 0; num802 < Main.maxNPCs; num802++) {
 							if (Main.npc[num802].active && Main.npc[num802].type == 264 && Main.npc[num802].ai[3] == 0f)
 								num801++;
 						}
@@ -21019,7 +_,7 @@
 						localAI[0] -= 6f;
 
 					if (!flag48 && localAI[0] <= 0f && this.ai[0] != 0f) {
-						for (int num810 = 0; num810 < 200; num810++) {
+						for (int num810 = 0; num810 < Main.maxNPCs; num810++) {
 							if (num810 != whoAmI && Main.npc[num810].active && Main.npc[num810].type == type && (Main.npc[num810].velocity.X != 0f || Main.npc[num810].velocity.Y != 0f))
 								localAI[0] = Main.rand.Next(60, 300);
 						}
@@ -21355,7 +_,7 @@
 					if (this.ai[0] == 0f) {
 						if (Main.netMode != 1) {
 							int num852 = 0;
-							for (int num853 = 0; num853 < 200; num853++) {
+							for (int num853 = 0; num853 < Main.maxNPCs; num853++) {
 								if (Main.npc[num853].active && Main.npc[num853].type == 267)
 									num852++;
 							}
@@ -24752,7 +_,7 @@
 								projectile.Kill();
 						}
 
-						for (int num1177 = 0; num1177 < 200; num1177++) {
+						for (int num1177 = 0; num1177 < Main.maxNPCs; num1177++) {
 							NPC nPC3 = Main.npc[num1177];
 							if (nPC3.active && nPC3.type == 400) {
 								nPC3.HitEffect(0, 9999.0);
@@ -24874,7 +_,7 @@
 							}
 						}
 
-						for (int num1187 = 0; num1187 < 200; num1187++) {
+						for (int num1187 = 0; num1187 < Main.maxNPCs; num1187++) {
 							NPC nPC4 = Main.npc[num1187];
 							if (nPC4.active && nPC4.type == 400) {
 								nPC4.active = false;
@@ -24891,7 +_,7 @@
 					}
 
 					if (this.ai[1] >= 60f) {
-						for (int num1189 = 0; num1189 < 200; num1189++) {
+						for (int num1189 = 0; num1189 < Main.maxNPCs; num1189++) {
 							NPC nPC5 = Main.npc[num1189];
 							if (nPC5.active && (nPC5.type == 400 || nPC5.type == 397 || nPC5.type == 396)) {
 								nPC5.active = false;
@@ -24959,7 +_,7 @@
 					Main.npc[(int)localAI[2]].netUpdate = true;
 				}
 
-				for (int num1191 = 0; num1191 < 200; num1191++) {
+				for (int num1191 = 0; num1191 < Main.maxNPCs; num1191++) {
 					NPC nPC6 = Main.npc[num1191];
 					if (nPC6.active && nPC6.type == 400) {
 						NPC nPC = nPC6;
@@ -25911,7 +_,7 @@
 					base.velocity.X = (base.velocity.X * (float)(num1260 - 1) + vector192.X) / (float)num1260;
 					base.velocity.Y = (base.velocity.Y * (float)(num1260 - 1) + vector192.Y) / (float)num1260;
 					float num1261 = 0.25f;
-					for (int num1262 = 0; num1262 < 200; num1262++) {
+					for (int num1262 = 0; num1262 < Main.maxNPCs; num1262++) {
 						if (num1262 != whoAmI && Main.npc[num1262].active && Main.npc[num1262].type == 400 && Vector2.Distance(base.Center, Main.npc[num1262].Center) < 150f) {
 							if (base.position.X < Main.npc[num1262].position.X)
 								base.velocity.X -= num1261;
@@ -26212,7 +_,7 @@
 						int num1283 = -1;
 						int num1284 = -1;
 						int num1285 = num1280;
-						for (int num1286 = 0; num1286 < 200; num1286++) {
+						for (int num1286 = 0; num1286 < Main.maxNPCs; num1286++) {
 							if (Main.npc[num1286].active && Main.npc[num1286].ai[3] == (float)num1282) {
 								if (num1283 == -1 && Main.npc[num1286].type == 397 && Main.npc[num1286].ai[2] == 0f)
 									num1283 = num1286;
@@ -26527,7 +_,7 @@
 
 					if (type == 421 && num1325 < 40f && Main.player[target].active && !Main.player[target].dead) {
 						bool flag84 = true;
-						for (int num1328 = 0; num1328 < 200; num1328++) {
+						for (int num1328 = 0; num1328 < Main.maxNPCs; num1328++) {
 							NPC nPC7 = Main.npc[num1328];
 							if (nPC7.active && nPC7.type == type && nPC7.ai[0] == 5f && nPC7.target == target) {
 								flag84 = false;
@@ -26645,7 +_,7 @@
 
 				if (type == 405) {
 					rotation = 0f;
-					for (int num1337 = 0; num1337 < 200; num1337++) {
+					for (int num1337 = 0; num1337 < Main.maxNPCs; num1337++) {
 						if (num1337 != whoAmI && Main.npc[num1337].active && Main.npc[num1337].type == type && Math.Abs(base.position.X - Main.npc[num1337].position.X) + Math.Abs(base.position.Y - Main.npc[num1337].position.Y) < (float)width) {
 							if (base.position.X < Main.npc[num1337].position.X)
 								base.velocity.X -= 0.05f;
@@ -26665,7 +_,7 @@
 
 					hide = (this.ai[0] == 5f);
 					rotation = base.velocity.X * 0.1f;
-					for (int num1338 = 0; num1338 < 200; num1338++) {
+					for (int num1338 = 0; num1338 < Main.maxNPCs; num1338++) {
 						if (num1338 != whoAmI && Main.npc[num1338].active && Main.npc[num1338].type == type && Math.Abs(base.position.X - Main.npc[num1338].position.X) + Math.Abs(base.position.Y - Main.npc[num1338].position.Y) < (float)width) {
 							if (base.position.X < Main.npc[num1338].position.X)
 								base.velocity.X -= 0.05f;
@@ -26690,7 +_,7 @@
 				noGravity = true;
 				noTileCollide = true;
 				knockBackResist = 0f;
-				for (int num1339 = 0; num1339 < 200; num1339++) {
+				for (int num1339 = 0; num1339 < Main.maxNPCs; num1339++) {
 					if (num1339 == whoAmI || !Main.npc[num1339].active || Main.npc[num1339].type != type)
 						continue;
 
@@ -27653,7 +_,7 @@
 				}
 
 				if (this.ai[0] == 0f || this.ai[0] == 1f) {
-					for (int num1399 = 0; num1399 < 200; num1399++) {
+					for (int num1399 = 0; num1399 < Main.maxNPCs; num1399++) {
 						if (num1399 != whoAmI && Main.npc[num1399].active && Main.npc[num1399].type == type) {
 							Vector2 vector213 = Main.npc[num1399].Center - base.Center;
 							if (vector213.Length() < (float)(width + height)) {
@@ -28803,7 +_,7 @@
 						vector226 *= num1500;
 						float num1502 = 10f;
 						base.velocity = (base.velocity * (num1502 - 1f) + vector226) / num1502;
-						for (int num1503 = 0; num1503 < 200; num1503++) {
+						for (int num1503 = 0; num1503 < Main.maxNPCs; num1503++) {
 							if (Main.npc[num1503].active && Main.npc[num1503].type == type && num1503 != whoAmI) {
 								Vector2 vector227 = Main.npc[num1503].Center - base.Center;
 								if (vector227.Length() < 40f) {
@@ -28853,7 +_,7 @@
 							this.ai[1] = 0f;
 						}
 
-						for (int num1507 = 0; num1507 < 200; num1507++) {
+						for (int num1507 = 0; num1507 < Main.maxNPCs; num1507++) {
 							if (Main.npc[num1507].active && Main.npc[num1507].type == type && num1507 != whoAmI) {
 								Vector2 vector228 = Main.npc[num1507].Center - base.Center;
 								if (vector228.Length() < 100f) {
@@ -28891,7 +_,7 @@
 				}
 
 				int num1508 = 300;
-				for (int num1509 = 0; num1509 < 200; num1509++) {
+				for (int num1509 = 0; num1509 < Main.maxNPCs; num1509++) {
 					if (Main.npc[num1509].active && Main.npc[num1509].type == type && num1509 != whoAmI) {
 						Vector2 vector229 = Main.npc[num1509].Center - base.Center;
 						if (vector229.Length() < 50f) {
@@ -29704,7 +_,7 @@
 					life = lifeMax;
 					if (this.ai[0] == 3f) {
 						SoundEngine.PlayTrackedSound(SoundID.DD2_WinScene, base.Center);
-						for (int num1574 = 0; num1574 < 200; num1574++) {
+						for (int num1574 = 0; num1574 < Main.maxNPCs; num1574++) {
 							NPC nPC8 = Main.npc[num1574];
 							if (nPC8.active && nPC8.type == 549) {
 								nPC8.ai[1] = 1f;
@@ -29797,7 +_,7 @@
 					dontTakeDamageFromHostiles = true;
 					life = lifeMax;
 					if (this.ai[0] == 0f) {
-						for (int num1585 = 0; num1585 < 200; num1585++) {
+						for (int num1585 = 0; num1585 < Main.maxNPCs; num1585++) {
 							NPC nPC9 = Main.npc[num1585];
 							if (nPC9.active && nPC9.type == 549) {
 								nPC9.ai[1] = 1f;
@@ -30035,7 +_,8 @@
 				timeLeft = 86400;
 			}
 
+			//TODO: Replace this downcast.
-			timeLeft -= Main.dayRate;
+			timeLeft -= (int)Main.dayRate;
 			if (timeLeft < 0)
 				timeLeft = 0;
 
@@ -30628,7 +_,7 @@
 
 		private void AI_124_DeerclopsLeg() {
 			int num = (int)ai[0];
-			if (num < 0 || num > 200) {
+			if (num < 0 || num > Main.maxNPCs) { // OR==?
 				active = false;
 				if (Main.netMode != 1)
 					NetMessage.SendData(23, -1, -1, null, whoAmI);
@@ -30765,7 +_,7 @@
 			alpha = Utils.Clamp(alpha - 5, 0, 255);
 			Vector2 targetPosition = Vector2.Zero.MoveTowards(targetData.Center - base.Center, 4f);
 			velocity = velocity.MoveTowards(targetPosition, 142f / (339f * (float)Math.PI));
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == type && i != whoAmI) {
 					Vector2 vector = Main.npc[i].Center - base.Center;
 					if (vector.Length() < 50f) {
@@ -30938,7 +_,7 @@
 
 				float num33 = 0f;
 				Vector2 zero = Vector2.Zero;
-				for (int l = 0; l < 200; l++) {
+				for (int l = 0; l < Main.maxNPCs; l++) {
 					NPC nPC = Main.npc[l];
 					if (nPC.active && nPC.damage > 0 && !nPC.friendly && nPC.Hitbox.Distance(base.Center) <= 100f) {
 						num33 += 1f;
@@ -31610,7 +_,7 @@
 				Main.npc[num32].velocity.Y = (float)Main.rand.Next(-30, 1) * 0.1f;
 				Main.npc[num32].ai[0] = -500 * Main.rand.Next(3);
 				Main.npc[num32].ai[1] = 0f;
-				if (Main.netMode == 2 && num32 < 200)
+				if (Main.netMode == 2 && num32 < Main.maxNPCs)
 					NetMessage.SendData(23, -1, -1, null, num32);
 			}
 		}
@@ -33324,7 +_,7 @@
 			localAI[1] = 15f;
 			float num6 = 0f;
 			Vector2 zero = Vector2.Zero;
-			for (int k = 0; k < 200; k++) {
+			for (int k = 0; k < Main.maxNPCs; k++) {
 				NPC nPC = Main.npc[k];
 				if (nPC.active && nPC.damage > 0 && !nPC.friendly && nPC.Hitbox.Distance(base.Center) <= 100f) {
 					num6 += 1f;
@@ -33534,7 +_,7 @@
 		public NPC AI_113_WindyBalloon_GetSlaveNPC() {
 			NPC nPC = null;
 			int num = (int)ai[3];
-			if (num >= 0 && num < 200) {
+			if (num >= 0 && num < Main.maxNPCs) {
 				nPC = Main.npc[num];
 				if (!nPC.active || nPC.type != 1 || nPC.ai[0] != -999f) {
 					nPC = null;
@@ -33971,7 +_,7 @@
 			}
 
 			dontTakeDamage = (dontTakeDamageFromHostiles = (ai[2] > 1f));
-			for (int k = 0; k < 200; k++) {
+			for (int k = 0; k < Main.maxNPCs; k++) {
 				if (k != whoAmI && Main.npc[k].active && Main.npc[k].aiStyle == 112 && Math.Abs(position.X - Main.npc[k].position.X) + Math.Abs(position.Y - Main.npc[k].position.Y) < (float)width * 1.5f) {
 					if (position.Y < Main.npc[k].position.Y)
 						velocity.Y -= 0.05f;
@@ -35103,7 +_,7 @@
 				}
 
 				if ((double)position.Y > Main.rockLayer * 16.0) {
-					for (int n = 0; n < 200; n++) {
+					for (int n = 0; n < Main.maxNPCs; n++) {
 						if (Main.npc[n].aiStyle == aiStyle)
 							Main.npc[n].active = false;
 					}
@@ -36476,7 +_,7 @@
 				}
 
 				if (num49 > 0) {
-					for (int num58 = 0; num58 < 200; num58++) {
+					for (int num58 = 0; num58 < Main.maxNPCs; num58++) {
 						if (Main.npc[num58].active && Main.npc[num58].type == type && num58 != base.whoAmI) {
 							Vector2 vector3 = Main.npc[num58].Center - base.Center;
 							if (vector3.Length() < 400f) {
@@ -36489,7 +_,7 @@
 					}
 				}
 				else {
-					for (int num59 = 0; num59 < 200; num59++) {
+					for (int num59 = 0; num59 < Main.maxNPCs; num59++) {
 						if (Main.npc[num59].active && Main.npc[num59].type == type && num59 != base.whoAmI) {
 							Vector2 vector4 = Main.npc[num59].Center - base.Center;
 							if (vector4.Length() < 60f) {
@@ -36641,7 +_,7 @@
 							if (Main.netMode != 1 && (double)(position.Y / 16f) > (Main.rockLayer + (double)Main.maxTilesY) / 2.0) {
 								active = false;
 								int num67 = (int)ai[0];
-								while (num67 > 0 && num67 < 200 && Main.npc[num67].active && Main.npc[num67].aiStyle == aiStyle) {
+								while (num67 > 0 && num67 < Main.maxNPCs && Main.npc[num67].active && Main.npc[num67].aiStyle == aiStyle) {
 									int num68 = (int)Main.npc[num67].ai[0];
 									Main.npc[num67].active = false;
 									life = 0;
@@ -37185,13 +_,14 @@
 			int num = -1;
 			int num2 = 7;
 			int num3 = 6;
-			int num4 = 2;
+			int num4 = 1; // TML: #ModdedChairsForNPCs: Changed from 2 to 1 to support non 2 tile high chairs
 			int num5 = 1;
-			int num6 = 2;
+			int num6 = 1; // TML: #ModdedChairsForNPCs: Changed from 2 to 1 to support non 2 tile high chairs
 			for (int i = point.X - num2; i <= point.X + num2; i += num5) {
 				for (int num7 = point.Y + num4; num7 >= point.Y - num3; num7 -= num6) {
 					Tile tile = Main.tile[i, num7];
-					if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type] && (tile.frameY % 40 != 0 || num7 + 1 <= point.Y + num4)) {
+					//if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type] && (tile.frameY % 40 != 0 || num7 + 1 <= point.Y + num4)) {
+					if (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type]) { // TML: #ModdedChairsForNPCs: Removed vanilla specific conditions
 						int num8 = Math.Abs(i - point.X) + Math.Abs(num7 - point.Y);
 						if (num == -1 || num8 < num) {
 							num = num8;
@@ -37212,6 +_,12 @@
 
 				point2.Y += 2;
 			}
+			else if (tile2.type >= TileID.Count) { // Check necessary as in this case vanilla changes (to vanilla tiles that aren't sittable by default) by the hook should not take effect
+				TileRestingInfo info = new TileRestingInfo(this, point2, Vector2.Zero, base.direction);
+				TileLoader.ModifySittingTargetInfo(point2.X, point2.Y, tile2.type, ref info);
+				point2 = info.AnchorTilePosition;
+				point2.Y += 1; // Set to tile *below* chair
+			}
 
 			floorX = point2.X;
 			floorY = point2.Y;
@@ -37219,16 +_,18 @@
 
 		private void AI_007_TryForcingSitting(int homeFloorX, int homeFloorY) {
 			Tile tile = Main.tile[homeFloorX, homeFloorY - 1];
-			bool flag = type != 638 && type != 656 && ai[0] != 5f;
+			//bool flag = type != 638 && type != 656 && ai[0] != 5f;
+			bool flag = !NPCID.Sets.CannotSitOnFurniture[type] && ai[0] != 5f;
 			if (flag)
-				flag &= (tile != null && tile.active() && (tile.type == 15 || tile.type == 497));
+				//flag &= (tile != null && tile.active() && (tile.type == 15 || tile.type == 497));
+				flag &= (tile != null && tile.active() && TileID.Sets.CanBeSatOnForNPCs[tile.type]); // TML: #ModdedChairsForNPCs
 
 			if (flag)
 				flag &= (tile.type != 15 || tile.frameY < 1080 || tile.frameY > 1098);
 
 			if (flag) {
 				Point b = (base.Bottom + Vector2.UnitY * -2f).ToTileCoordinates();
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					if (Main.npc[i].active && Main.npc[i].aiStyle == 7 && Main.npc[i].townNPC && Main.npc[i].ai[0] == 5f && (Main.npc[i].Bottom + Vector2.UnitY * -2f).ToTileCoordinates() == b) {
 						flag = false;
 						break;
@@ -37239,8 +_,10 @@
 			if (flag) {
 				ai[0] = 5f;
 				ai[1] = 900 + Main.rand.Next(10800);
-				direction = ((tile.frameX != 0) ? 1 : (-1));
-				base.Bottom = new Vector2(homeFloorX * 16 + 8 + 2 * direction, homeFloorY * 16);
+				// TML: #ModdedChairsForNPCs
+				SitDown(new Point(homeFloorX, homeFloorY - 1), out int targetDirection, out var bottom);
+				direction = targetDirection;
+				base.Bottom = bottom;
 				velocity = Vector2.Zero;
 				localAI[3] = 0f;
 				netUpdate = true;
@@ -37252,6 +_,7 @@
 			if (type == 638 || type == 656)
 				num = 0;
 
+			//patch file: flag
 			bool flag = Main.raining;
 			if (!Main.dayTime)
 				flag = true;
@@ -37340,6 +_,8 @@
 					num2 += 0.15f;
 					defense += 8;
 				}
+
+				NPCLoader.BuffTownNPC(ref num2, ref defense);
 			}
 
 			if (type == 142 && Main.netMode != 1 && !Main.xMas) {
@@ -37399,7 +_,7 @@
 					break;
 			}
 
-			if (type >= 0 && type < 670 && NPCID.Sets.TownCritter[type] && target == 255) {
+			if (type >= 0 && NPCID.Sets.TownCritter[type] && target == 255) {
 				TargetClosest();
 				if (position.X < Main.player[target].position.X) {
 					base.direction = 1;
@@ -37495,7 +_,7 @@
 					base.direction = -1;
 			}
 
-			if (!WorldGen.InWorld(num4, num5) || Main.tile[num4, num5] == null)
+			if (!WorldGen.InWorld(num4, num5) || Main.netMode == 1 && !Main.sectionManager.TileLoaded(num4, num5))
 				return;
 
 			if (!homeless && Main.netMode != 1 && townNPC && (flag || Main.tileDungeon[Main.tile[num4, num5].type]) && !AI_007_TownEntities_IsInAGoodRestingSpot(num4, num5, floorX, floorY)) {
@@ -37538,8 +_,15 @@
 			int num10 = -1;
 			int num11 = -1;
 			if (!flag6 && Main.netMode != 1 && !flag3) {
-				for (int l = 0; l < 200; l++) {
-					if (!Main.npc[l].active || Main.npc[l].friendly || Main.npc[l].damage <= 0 || !(Main.npc[l].Distance(base.Center) < num6) || (type == 453 && NPCID.Sets.Skeletons[Main.npc[l].type]) || (!Main.npc[l].noTileCollide && !Collision.CanHit(base.Center, 0, 0, Main.npc[l].Center, 0, 0)))
+				for (int l = 0; l < Main.maxNPCs; l++) {
+					if (!Main.npc[l].active) continue;
+					bool? modCanHit = NPCLoader.CanHitNPC(Main.npc[l], this);
+					if (modCanHit.HasValue && !modCanHit.Value)
+						continue;
+
+					bool canHitVal = modCanHit.HasValue && modCanHit.Value;
+					// TODO: NPCLoader.CanHitNPC should return a plain bool. The only use of "override true" below is to force the skeleton merchant to be hit by skeletons
+					if (!Main.npc[l].active || Main.npc[l].friendly || Main.npc[l].damage <= 0 || !(Main.npc[l].Distance(base.Center) < num6) || (type == 453 && NPCID.Sets.Skeletons[Main.npc[l].type] && canHitVal) || (!Main.npc[l].noTileCollide && !Collision.CanHit(base.Center, 0, 0, Main.npc[l].Center, 0, 0)))
 						continue;
 
 					bool flag12 = Main.npc[l].CanBeChasedBy(this);
@@ -37793,7 +_,7 @@
 
 					if (closeDoor && ((position.X + (float)(width / 2)) / 16f > (float)(doorX + 2) || (position.X + (float)(width / 2)) / 16f < (float)(doorX - 2))) {
 						Tile tileSafely = Framing.GetTileSafely(doorX, doorY);
-						if (tileSafely.type == 11) {
+						if (TileLoader.CloseDoorID(tileSafely) >= 0) {
 							if (WorldGen.CloseDoor(doorX, doorY)) {
 								closeDoor = false;
 								NetMessage.SendData(19, -1, -1, null, 1, doorX, doorY, base.direction);
@@ -37957,7 +_,7 @@
 						Tile tileSafely4 = Framing.GetTileSafely(num18, num19 - 1);
 						Tile tileSafely5 = Framing.GetTileSafely(num18, num19 - 2);
 						bool flag18 = height / 16 < 3;
-						if (townNPC && tileSafely5.nactive() && (tileSafely5.type == 10 || tileSafely5.type == 388) && (Main.rand.Next(10) == 0 || flag)) {
+						if ((townNPC || NPCID.Sets.AllowDoorInteraction[type]) && tileSafely5.nactive() && (TileLoader.OpenDoorID(tileSafely5) >= 0 || tileSafely5.type == 388) && (Main.rand.Next(10) == 0 || flag)) {
 							if (Main.netMode != 1) {
 								if (WorldGen.OpenDoor(num18, num19 - 2, base.direction)) {
 									closeDoor = true;
@@ -38109,7 +_,8 @@
 				if (ai[0] == 5f) {
 					Point coords = (base.Bottom + Vector2.UnitY * -2f).ToTileCoordinates();
 					Tile tile = Main.tile[coords.X, coords.Y];
-					if (tile.type != 15 && tile.type != 497)
+					//if (tile.type != 15 && tile.type != 497)
+					if (!TileID.Sets.CanBeSatOnForNPCs[tile.type]) // TML: #ModdedChairsForNPCs 
 						ai[1] = 0f;
 					else
 						Main.sittingManager.AddNPC(whoAmI, coords);
@@ -38281,13 +_,19 @@
 					num28 = 589;
 					num30 = 7f;
 					num29 = 22;
+					//Patch context: num28 - proj type, num29 - damage, num30 - speed multiplier, num31 - attack delay, num32 - attack cooldown.
 					num31 = 1;
 					num32 = 10;
 					maxValue = 1;
 					knockBack = 2f;
+					//Patch context: num33 - gravity correction.
 					num33 = 10f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num29, ref knockBack);
+				NPCLoader.TownNPCAttackCooldown(this, ref num32, ref maxValue);
+				NPCLoader.TownNPCAttackProj(this, ref num28, ref num31);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num30, ref num33, ref num35);
 				if (Main.expertMode)
 					num29 = (int)((float)num29 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -38307,6 +_,7 @@
 						vec = new Vector2(spriteDirection, -1f);
 
 					vec *= num30;
+					// Context for the patch above: num35 - random speed offset.
 					vec += Utils.RandomVector2(Main.rand, 0f - num35, num35);
 					int num36 = 1000;
 					num36 = ((type == 124) ? Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num28, num29, knockBack, Main.myPlayer, 0f, whoAmI) : ((type != 142) ? Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num28, num29, knockBack, Main.myPlayer) : Projectile.NewProjectile(GetSpawnSource_ForProjectile(), base.Center.X + (float)(spriteDirection * 16), base.Center.Y - 2f, vec.X, vec.Y, num28, num29, knockBack, Main.myPlayer, 0f, Main.rand.Next(5))));
@@ -38332,7 +_,7 @@
 				int num41 = 0;
 				int maxValue2 = 0;
 				float knockBack2 = 0f;
-				int num42 = 0;
+				float num42 = 0;
 				bool flag21 = false;
 				float num43 = 0f;
 				if ((float)NPCID.Sets.AttackTime[type] == ai[1]) {
@@ -38497,6 +_,7 @@
 
 					if (localAI[3] > (float)num40) {
 						num40 = 48;
+						//Patch context: flag20 means 'in between shots'.
 						flag21 = true;
 					}
 
@@ -38510,6 +_,7 @@
 				}
 				else if (type == 209) {
 					num37 = Utils.SelectRandom<int>(Main.rand, 134, 133, 135);
+					//Patch context: num37 - proj type, num38 - damage, num39 - speed multiplier, num40 - attack delay, num41 - attack cooldown.
 					num40 = 1;
 					switch (num37) {
 						case 135:
@@ -38539,6 +_,12 @@
 					}
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num38, ref knockBack2);
+				NPCLoader.TownNPCAttackCooldown(this, ref num41, ref maxValue2);
+				NPCLoader.TownNPCAttackProj(this, ref num37, ref num40);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num39, ref num42, ref num43);
+				NPCLoader.TownNPCAttackShoot(this, ref flag21);
+
 				if (Main.expertMode)
 					num38 = (int)((float)num38 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -38659,6 +_,7 @@
 				else if (type == 663) {
 					num47 = 950;
 					num48 = 20;
+					//Patch context: num47 - proj type, num48 - damage, num50 - attack delay, num51 - attack cooldown.
 					num50 = 15;
 					num51 = 0;
 					maxValue3 = 0;
@@ -38674,6 +_,11 @@
 					knockBack3 = 3f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num48, ref knockBack3);
+				NPCLoader.TownNPCAttackCooldown(this, ref num51, ref maxValue3);
+				NPCLoader.TownNPCAttackProj(this, ref num47, ref num50);
+				NPCLoader.TownNPCAttackProjSpeed(this, ref num49, ref num52, ref num55);
+				NPCLoader.TownNPCAttackMagic(this, ref num54);
 				if (Main.expertMode)
 					num48 = (int)((float)num48 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -38684,12 +_,14 @@
 				if (localAI[3] == (float)num50 && Main.netMode != 1) {
 					Vector2 vec4 = Vector2.Zero;
 					if (num56 != -1)
+						//Patch context: num52 is gravity correction.
 						vec4 = DirectionTo(Main.npc[num56].Center + new Vector2(0f, (0f - num52) * MathHelper.Clamp(Distance(Main.npc[num56].Center) / num53, 0f, 1f)));
 
 					if (vec4.HasNaNs() || Math.Sign(vec4.X) != spriteDirection)
 						vec4 = new Vector2(spriteDirection, 0f);
 
 					vec4 *= num49;
+					// Context for the patch above: num55 - random speed offset.
 					vec4 += Utils.RandomVector2(Main.rand, 0f - num55, num55);
 					if (type == 108) {
 						int num57 = Utils.SelectRandom<int>(Main.rand, 1, 1, 1, 1, 2, 2, 3);
@@ -38740,6 +_,7 @@
 					}
 				}
 
+				//Patch context: num54 is aura light multiplier
 				if (num54 > 0f) {
 					Vector3 vector5 = NPCID.Sets.MagicAuraColor[type].ToVector3() * num54;
 					Lighting.AddLight(base.Center, vector5.X, vector5.Y, vector5.Z);
@@ -38799,11 +_,15 @@
 				else if (type == 637 || type == 638 || type == 656) {
 					num67 = 10;
 					num69 = (num70 = 32);
+					//Patch context: num66 - attack cooldown,  num67 - damage, num68 - knockback, num69 & num70 - width and height, maxValue4 - random extra cooldown
 					num66 = 15;
 					maxValue4 = 8;
 					num68 = 3f;
 				}
 
+				NPCLoader.TownNPCAttackStrength(this, ref num67, ref num68);
+				NPCLoader.TownNPCAttackCooldown(this, ref num66, ref maxValue4);
+				NPCLoader.TownNPCAttackSwing(this, ref num69, ref num70);
 				if (Main.expertMode)
 					num67 = (int)((float)num67 * Main.GameModeInfo.TownNPCDamageMultiplier);
 
@@ -38819,7 +_,7 @@
 					itemRectangle.Y -= num70;
 					TweakSwingStats(NPCID.Sets.AttackTime[type] * 2, (int)ai[1], spriteDirection, ref itemRectangle);
 					int myPlayer = Main.myPlayer;
-					for (int num71 = 0; num71 < 200; num71++) {
+					for (int num71 = 0; num71 < Main.maxNPCs; num71++) {
 						NPC nPC2 = Main.npc[num71];
 						if (nPC2.active && nPC2.immune[myPlayer] == 0 && !nPC2.dontTakeDamage && !nPC2.friendly && nPC2.damage > 0 && itemRectangle.Intersects(nPC2.Hitbox) && (nPC2.noTileCollide || Collision.CanHit(position, width, height, nPC2.position, nPC2.width, nPC2.height))) {
 							nPC2.StrikeNPCNoInteraction(num67, num68, spriteDirection);
@@ -38914,7 +_,7 @@
 
 			if (flag24 && type == 20) {
 				flag24 = false;
-				for (int num77 = 0; num77 < 200; num77++) {
+				for (int num77 = 0; num77 < Main.maxNPCs; num77++) {
 					NPC nPC3 = Main.npc[num77];
 					if (nPC3.active && nPC3.townNPC && !(Distance(nPC3.Center) > 1200f) && nPC3.FindBuffIndex(165) == -1) {
 						flag24 = true;
@@ -38928,7 +_,7 @@
 				num78 = ((Main.rand.Next(2) != 0) ? (num78 * Main.rand.Next(1, 3)) : (num78 * Main.rand.Next(1, 4)));
 				int num79 = 100;
 				int num80 = 20;
-				for (int num81 = 0; num81 < 200; num81++) {
+				for (int num81 = 0; num81 < Main.maxNPCs; num81++) {
 					NPC nPC4 = Main.npc[num81];
 					bool flag25 = (nPC4.ai[0] == 1f && nPC4.closeDoor) || (nPC4.ai[0] == 1f && nPC4.ai[1] > 200f) || nPC4.ai[0] > 1f || nPC4.wet;
 					if (nPC4 != this && nPC4.active && nPC4.CanBeTalkedTo && !flag25 && nPC4.Distance(base.Center) < (float)num79 && nPC4.Distance(base.Center) > (float)num80 && Collision.CanHit(base.Center, 0, 0, nPC4.Center, 0, 0)) {
@@ -38952,7 +_,7 @@
 				num83 = ((Main.rand.Next(2) != 0) ? (num83 * Main.rand.Next(1, 3)) : (num83 * Main.rand.Next(1, 4)));
 				int num84 = 100;
 				int num85 = 20;
-				for (int num86 = 0; num86 < 200; num86++) {
+				for (int num86 = 0; num86 < Main.maxNPCs; num86++) {
 					NPC nPC5 = Main.npc[num86];
 					bool flag26 = (nPC5.ai[0] == 1f && nPC5.closeDoor) || (nPC5.ai[0] == 1f && nPC5.ai[1] > 200f) || nPC5.ai[0] > 1f || nPC5.wet;
 					if (nPC5 != this && nPC5.active && nPC5.CanBeTalkedTo && !NPCID.Sets.IsTownPet[nPC5.type] && !flag26 && nPC5.Distance(base.Center) < (float)num84 && nPC5.Distance(base.Center) > (float)num85 && Collision.CanHit(base.Center, 0, 0, nPC5.Center, 0, 0)) {
@@ -39037,7 +_,7 @@
 				Point b = (base.Bottom + Vector2.UnitY * -2f).ToTileCoordinates();
 				bool flag27 = WorldGen.InWorld(b.X, b.Y, 1);
 				if (flag27) {
-					for (int num97 = 0; num97 < 200; num97++) {
+					for (int num97 = 0; num97 < Main.maxNPCs; num97++) {
 						if (Main.npc[num97].active && Main.npc[num97].aiStyle == 7 && Main.npc[num97].townNPC && Main.npc[num97].ai[0] == 5f && (Main.npc[num97].Bottom + Vector2.UnitY * -2f).ToTileCoordinates() == b) {
 							flag27 = false;
 							break;
@@ -39054,15 +_,18 @@
 
 				if (flag27) {
 					Tile tile2 = Main.tile[b.X, b.Y];
-					flag27 = (tile2.type == 15 || tile2.type == 497);
+					//flag27 = (tile2.type == 15 || tile2.type == 497);
+					flag27 = TileID.Sets.CanBeSatOnForNPCs[tile2.type]; // TML: #ModdedChairsForNPCs
 					if (flag27 && tile2.type == 15 && tile2.frameY >= 1080 && tile2.frameY <= 1098)
 						flag27 = false;
 
 					if (flag27) {
 						ai[0] = 5f;
 						ai[1] = 900 + Main.rand.Next(10800);
-						base.direction = ((tile2.frameX != 0) ? 1 : (-1));
-						base.Bottom = new Vector2(b.X * 16 + 8 + 2 * base.direction, b.Y * 16 + 16);
+						// TML: #ModdedChairsForNPCs
+						SitDown(b, out int targetDirection, out var bottom);
+						base.direction = targetDirection;
+						base.Bottom = bottom;
 						velocity = Vector2.Zero;
 						localAI[3] = 0f;
 						netUpdate = true;
@@ -39089,7 +_,7 @@
 
 			if (Main.netMode != 1 && ai[0] < 2f && velocity.Y == 0f && type == 18 && breath > 0) {
 				int num99 = -1;
-				for (int num100 = 0; num100 < 200; num100++) {
+				for (int num100 = 0; num100 < Main.maxNPCs; num100++) {
 					NPC nPC6 = Main.npc[num100];
 					if (nPC6.active && nPC6.townNPC && nPC6.life != nPC6.lifeMax && (num99 == -1 || nPC6.lifeMax - nPC6.life > Main.npc[num99].lifeMax - Main.npc[num99].life) && Collision.CanHitLine(position, width, height, nPC6.position, nPC6.width, nPC6.height) && Distance(nPC6.Center) < 500f)
 						num99 = num100;
@@ -39237,7 +_,7 @@
 					Rectangle hitbox = base.Hitbox;
 					hitbox.X -= 20;
 					hitbox.Width += 40;
-					for (int i = 0; i < 200; i++) {
+					for (int i = 0; i < Main.maxNPCs; i++) {
 						if (Main.npc[i].active && Main.npc[i].friendly && i != whoAmI && Main.npc[i].velocity.X == 0f && hitbox.Intersects(Main.npc[i].Hitbox)) {
 							keepwalking = true;
 							break;
@@ -40151,7 +_,7 @@
 
 				if (ai[2] == 0f) {
 					int num41 = 0;
-					for (int n = 0; n < 200; n++) {
+					for (int n = 0; n < Main.maxNPCs; n++) {
 						if (Main.npc[n].active && Main.npc[n].type == 516)
 							num41++;
 					}
@@ -41274,7 +_,7 @@
 			}
 			else if (type == 415) {
 				hide = false;
-				for (int num101 = 0; num101 < 200; num101++) {
+				for (int num101 = 0; num101 < Main.maxNPCs; num101++) {
 					if (Main.npc[num101].active && Main.npc[num101].type == 416 && Main.npc[num101].ai[0] == (float)whoAmI) {
 						hide = true;
 						break;
@@ -41348,7 +_,7 @@
 						base.position -= netOffset;
 					}
 
-					for (int num104 = 0; num104 < 200; num104++) {
+					for (int num104 = 0; num104 < Main.maxNPCs; num104++) {
 						if (num104 != whoAmI && Main.npc[num104].active && Main.npc[num104].type == type && Math.Abs(base.position.X - Main.npc[num104].position.X) + Math.Abs(base.position.Y - Main.npc[num104].position.Y) < (float)width) {
 							if (base.position.X < Main.npc[num104].position.X)
 								base.velocity.X -= 0.05f;
@@ -41427,7 +_,7 @@
 							base.velocity.Y += 0.15f;
 					}
 
-					for (int num108 = 0; num108 < 200; num108++) {
+					for (int num108 = 0; num108 < Main.maxNPCs; num108++) {
 						if (num108 != whoAmI && Main.npc[num108].active && Main.npc[num108].type == type && Math.Abs(base.position.X - Main.npc[num108].position.X) + Math.Abs(base.position.Y - Main.npc[num108].position.Y) < (float)width) {
 							if (base.position.X < Main.npc[num108].position.X)
 								base.velocity.X -= 0.05f;
@@ -41481,7 +_,7 @@
 					base.velocity.Y = -6f;
 				}
 
-				for (int num110 = 0; num110 < 200; num110++) {
+				for (int num110 = 0; num110 < Main.maxNPCs; num110++) {
 					if (num110 != whoAmI && Main.npc[num110].active && Main.npc[num110].type == type && Math.Abs(base.position.X - Main.npc[num110].position.X) + Math.Abs(base.position.Y - Main.npc[num110].position.Y) < (float)width) {
 						if (base.position.X < Main.npc[num110].position.X)
 							base.velocity.X -= 0.1f;
@@ -42416,7 +_,7 @@
 					Main.tile[num177 - direction, num178 + 1] = new Tile();
 
 				Main.tile[num177, num178 + 1].halfBrick();
-				if (Main.tile[num177, num178 - 1].nactive() && (Main.tile[num177, num178 - 1].type == 10 || Main.tile[num177, num178 - 1].type == 388) && flag8) {
+				if (Main.tile[num177, num178 - 1].nactive() && (TileLoader.IsClosedDoor(Main.tile[num177, num178 - 1]) || Main.tile[num177, num178 - 1].type == 388) && flag8) {
 					ai[2] += 1f;
 					ai[3] = 0f;
 					if (ai[2] >= 60f) {
@@ -42455,7 +_,7 @@
 									NetMessage.SendData(17, -1, -1, null, 0, num177, num178 - 1);
 							}
 							else {
-								if (Main.tile[num177, num178 - 1].type == 10) {
+								if (TileLoader.OpenDoorID(Main.tile[num177, num178 - 1]) >= 0) {
 									bool flag24 = WorldGen.OpenDoor(num177, num178 - 1, direction);
 									if (!flag24) {
 										ai[3] = num52;
@@ -43608,7 +_,7 @@
 								Tile tileSafely = Framing.GetTileSafely(i, j);
 								bool flag2 = tileSafely.active() && Main.tileSolid[tileSafely.type] && !Main.tileFrameImportant[tileSafely.type];
 								if (flag && flag2) {
-									int num38 = WorldGen.KillTile_GetTileDustAmount(fail: true, tileSafely);
+									int num38 = WorldGen.KillTile_GetTileDustAmount(true, tileSafely, i, j);
 									for (int k = 0; k < num38; k++) {
 										Dust obj = Main.dust[WorldGen.KillTile_MakeTileDust(i, j, tileSafely)];
 										obj.velocity.Y -= 3f + (float)num37 * 1.5f;
@@ -43651,7 +_,7 @@
 						}
 
 						List<NPC> list = new List<NPC>();
-						for (int n = 0; n < 200; n++) {
+						for (int n = 0; n < Main.maxNPCs; n++) {
 							NPC nPC = Main.npc[n];
 							if (nPC.active && nPC.type == 549)
 								list.Add(nPC);
@@ -43742,7 +_,7 @@
 			if (type == 546) {
 				num2 = 4;
 				bool flag4 = velocity.Y == 0f;
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					if (i != whoAmI && Main.npc[i].active && Main.npc[i].type == type && Math.Abs(base.position.X - Main.npc[i].position.X) + Math.Abs(base.position.Y - Main.npc[i].position.Y) < (float)width) {
 						if (base.position.X < Main.npc[i].position.X)
 							velocity.X -= 0.05f;
@@ -44201,7 +_,7 @@
 			bool flag21 = false;
 			bool flag22 = false;
 			bool flag23 = false;
-			LegacySoundStyle style = null;
+			SoundStyle? style = null;
 			int num20 = 0;
 			bool flag24 = false;
 			float num21 = 1f;
@@ -44845,7 +_,7 @@
 
 			if (flag28) {
 				bool flag31 = base.velocity.Y == 0f;
-				for (int num50 = 0; num50 < 200; num50++) {
+				for (int num50 = 0; num50 < Main.maxNPCs; num50++) {
 					if (num50 != whoAmI && Main.npc[num50].active && Main.npc[num50].type == type && Math.Abs(base.position.X - Main.npc[num50].position.X) + Math.Abs(base.position.Y - Main.npc[num50].position.Y) < (float)width) {
 						if (base.position.X < Main.npc[num50].position.X)
 							base.velocity.X -= num29;
@@ -45053,8 +_,13 @@
 
 			if (!flag20) {
 				if (ai[3] < (float)num19 && flag21) {
+					/*
 					if (num20 > 0 && Main.rand.Next(num20) == 0)
 						SoundEngine.PlayTrackedSound(style, base.Center);
+					*/
+
+					if (num20 > 0 && Main.rand.Next(num20) == 0 && style.HasValue)
+						SoundEngine.PlayTrackedSound(style.Value, base.Center);
 
 					bool hasValidTarget = HasValidTarget;
 					nPCTargetingMethod(this, faceTarget: true, null);
@@ -45232,7 +_,7 @@
 				Tile tileSafely4 = Framing.GetTileSafely(num64, num65 - 1);
 				Tile tileSafely5 = Framing.GetTileSafely(num64, num65 - 2);
 				Tile tileSafely6 = Framing.GetTileSafely(num64, num65 - 3);
-				if (flag8 && tileSafely4.nactive() && (tileSafely4.type == 10 || tileSafely4.type == 388)) {
+				if (flag8 && tileSafely4.nactive() && (TileLoader.IsClosedDoor(tileSafely4) || tileSafely4.type == 388)) {
 					ai[0] += 1f;
 					ai[3] = 0f;
 					if (ai[0] >= 60f) {
@@ -45262,7 +_,7 @@
 									NetMessage.SendData(17, -1, -1, null, 0, num64, num65 - 1);
 							}
 							else {
-								if (tileSafely4.type == 10) {
+								if (TileLoader.IsClosedDoor(tileSafely4)) {
 									bool flag38 = WorldGen.OpenDoor(num64, num65 - 1, direction);
 									if (!flag38) {
 										ai[3] = num19;
@@ -45474,7 +_,7 @@
 				velocity = Vector2.Zero;
 				netUpdate = true;
 				List<int> list = new List<int>();
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					if (Main.npc[i].active && Main.npc[i].type == 440 && Main.npc[i].ai[3] == (float)whoAmI)
 						list.Add(i);
 				}
@@ -45522,7 +_,7 @@
 					NetMessage.SendData(28, -1, -1, null, whoAmI, -1f);
 
 				new List<int>().Add(whoAmI);
-				for (int j = 0; j < 200; j++) {
+				for (int j = 0; j < Main.maxNPCs; j++) {
 					if (Main.npc[j].active && Main.npc[j].type == 440 && Main.npc[j].ai[3] == (float)whoAmI) {
 						Main.npc[j].life = 0;
 						Main.npc[j].HitEffect();
@@ -45703,7 +_,7 @@
 						List<int> list2 = new List<int>();
 						int num15 = 0;
 						list2.Add(whoAmI);
-						for (int k = 0; k < 200; k++) {
+						for (int k = 0; k < Main.maxNPCs; k++) {
 							if (Main.npc[k].active && Main.npc[k].type == 440 && Main.npc[k].ai[3] == (float)whoAmI)
 								list2.Add(k);
 						}
@@ -45788,7 +_,7 @@
 				if (this.ai[1] >= 4f && flag2 && (int)(this.ai[1] - 4f) % num == 0) {
 					if (Main.netMode != 1) {
 						List<int> list3 = new List<int>();
-						for (int l = 0; l < 200; l++) {
+						for (int l = 0; l < Main.maxNPCs; l++) {
 							if (Main.npc[l].active && Main.npc[l].type == 440 && Main.npc[l].ai[3] == (float)whoAmI)
 								list3.Add(l);
 						}
@@ -45846,7 +_,7 @@
 				if (this.ai[1] >= 4f && flag2 && (int)(this.ai[1] - 4f) % num2 == 0) {
 					if ((int)(this.ai[1] - 4f) / num2 == 2) {
 						List<int> list4 = new List<int>();
-						for (int num18 = 0; num18 < 200; num18++) {
+						for (int num18 = 0; num18 < Main.maxNPCs; num18++) {
 							if (Main.npc[num18].active && Main.npc[num18].type == 440 && Main.npc[num18].ai[3] == (float)whoAmI)
 								list4.Add(num18);
 						}
@@ -45910,7 +_,7 @@
 
 				if (this.ai[1] == 20f && flag2 && Main.netMode != 1) {
 					List<int> list5 = new List<int>();
-					for (int num23 = 0; num23 < 200; num23++) {
+					for (int num23 = 0; num23 < Main.maxNPCs; num23++) {
 						if (Main.npc[num23].active && Main.npc[num23].type == 440 && Main.npc[num23].ai[3] == (float)whoAmI)
 							list5.Add(num23);
 					}
@@ -45965,7 +_,7 @@
 						localAI[1] += 1f;
 						Vector2 spinningpoint = new Vector2(180f, 0f);
 						List<int> list6 = new List<int>();
-						for (int num27 = 0; num27 < 200; num27++) {
+						for (int num27 = 0; num27 < Main.maxNPCs; num27++) {
 							if (Main.npc[num27].active && Main.npc[num27].type == 440 && Main.npc[num27].ai[3] == (float)whoAmI)
 								list6.Add(num27);
 						}
@@ -46128,7 +_,7 @@
 				if (this.ai[1] >= 4f && flag2 && (int)(this.ai[1] - 4f) % num5 == 0) {
 					if ((int)(this.ai[1] - 4f) / num5 == 2) {
 						List<int> list7 = new List<int>();
-						for (int num42 = 0; num42 < 200; num42++) {
+						for (int num42 = 0; num42 < Main.maxNPCs; num42++) {
 							if (Main.npc[num42].active && Main.npc[num42].type == 440 && Main.npc[num42].ai[3] == (float)whoAmI)
 								list7.Add(num42);
 						}
@@ -46190,7 +_,7 @@
 				localAI[2] = 13f;
 				if (this.ai[1] >= 4f && flag2 && (int)(this.ai[1] - 4f) % num7 == 0) {
 					List<int> list8 = new List<int>();
-					for (int num49 = 0; num49 < 200; num49++) {
+					for (int num49 = 0; num49 < Main.maxNPCs; num49++) {
 						if (Main.npc[num49].active && Main.npc[num49].type == 440 && Main.npc[num49].ai[3] == (float)whoAmI)
 							list8.Add(num49);
 					}
@@ -46364,7 +_,7 @@
 			}
 
 			if (flag4) {
-				for (int j = 0; j < 200; j++) {
+				for (int j = 0; j < Main.maxNPCs; j++) {
 					if (j != whoAmI && Main.npc[j].active && Main.npc[j].type == type && Math.Abs(position.X - Main.npc[j].position.X) + Math.Abs(position.Y - Main.npc[j].position.Y) < (float)width) {
 						if (position.X < Main.npc[j].position.X)
 							velocity.X -= num14;
@@ -46676,7 +_,7 @@
 					Vector2 minimum = base.Center + new Vector2(-600f, -200f);
 					Vector2 maximum = base.Center + new Vector2(600f, 200f);
 					int num14 = 0;
-					for (int i = 0; i < 200; i++) {
+					for (int i = 0; i < Main.maxNPCs; i++) {
 						NPC nPC = Main.npc[i];
 						if (nPC.active && nPC.lifeMax != nPC.life && nPC.Center.Between(minimum, maximum) && ++num14 >= 2) {
 							flag8 = true;
@@ -47012,7 +_,7 @@
 			}
 
 			if (flag2) {
-				for (int j = 0; j < 200; j++) {
+				for (int j = 0; j < Main.maxNPCs; j++) {
 					if (j != whoAmI && Main.npc[j].active && Main.npc[j].type == type && Math.Abs(base.position.X - Main.npc[j].position.X) + Math.Abs(base.position.Y - Main.npc[j].position.Y) < (float)width) {
 						if (base.position.X < Main.npc[j].position.X)
 							velocity.X -= num11;
@@ -47243,6 +_,10 @@
 			if (type == 441 || type == 37 || type == 633)
 				return false;
 
+			if (!NPCLoader.UsesPartyHat(this)) {
+				return false;
+			}
+
 			if (ForcePartyHatOn)
 				return true;
 
@@ -47294,6 +_,10 @@
 				num = TextureAssets.Npc[type].Height() / Main.npcFrameCount[type];
 			}
 
+			NPCLoader.FindFrame(this, num);
+		}
+
+		public void VanillaFindFrame(int num, bool isLikeATownNPC, int type) {
 			int num2 = 0;
 			if (aiAction == 0)
 				num2 = ((velocity.Y < 0f) ? 2 : ((velocity.Y > 0f) ? 3 : ((velocity.X != 0f) ? 1 : 0)));
@@ -55372,7 +_,10 @@
 					if (Main.tile[x, y].type == 467)
 						number2 = 5;
 
-					NetMessage.SendData(34, -1, -1, null, number2, x, y, 0f, number);
+					if (Main.tile[x, y].type >= TileID.Count)
+						number2 = 101;
+
+					NetMessage.SendData(34, -1, -1, null, number2, x, y, 0f, number, Main.tile[x, y].type, 0);
 					NetMessage.SendTileSquare(-1, x, y, 3);
 				}
 
@@ -55464,7 +_,7 @@
 				}
 			}
 
-			for (int j = 0; j < 200; j++) {
+			for (int j = 0; j < Main.maxNPCs; j++) {
 				NPC nPC = Main.npc[j];
 				if (nPC.active && nPC.type == 548) {
 					float num6 = Vector2.Distance(center, nPC.Center);
@@ -55717,6 +_,9 @@
 			if (!active || DoesntDespawnToInactivity())
 				return;
 
+			if (!NPCLoader.CheckActive(this))
+				return;
+
 			if (townNPC) {
 				AddIntoPlayersTownNPCSlots();
 				return;
@@ -55790,7 +_,7 @@
 			if (timeLeft <= 0)
 				flag = false;
 
-			if (!flag && Main.netMode != 1) {
+			if (!flag && Main.netMode != 1 && !NPCLoader.SavesAndLoads(this)) {
 				noSpawnCycle = true;
 				active = false;
 				if (Main.netMode == 2) {
@@ -55811,7 +_,7 @@
 				return;
 
 			int num = (int)ai[0];
-			while (num != whoAmI && num > 0 && num < 200) {
+			while (num != whoAmI && num > 0 && num < Main.maxNPCs) {
 				NPC nPC = Main.npc[num];
 				if (nPC.active && nPC.aiStyle == 6) {
 					nPC.active = false;
@@ -55886,6 +_,9 @@
 				return;
 			}
 
+			if (!NPCLoader.CheckDead(this))
+				return;
+
 			noSpawnCycle = true;
 			if (townNPC && type != 37 && type != 453) {
 				if (Main.netMode != 2)
@@ -55934,7 +_,9 @@
 			if (DeathSound != null)
 				SoundEngine.PlaySound(DeathSound, base.position);
 
+			if (NPCLoader.SpecialOnKill(this)) {
+			}
-			if (type == 13 || type == 14 || type == 15) {
+			else if (type == 13 || type == 14 || type == 15) {
 				DropEoWLoot();
 			}
 			else if (type == 134) {
@@ -55942,7 +_,7 @@
 				Vector2 center = Main.player[target].Center;
 				float num3 = 100000000f;
 				Vector2 position2 = base.position;
-				for (int k = 0; k < 200; k++) {
+				for (int k = 0; k < Main.maxNPCs; k++) {
 					if (Main.npc[k].active && (Main.npc[k].type == 134 || Main.npc[k].type == 135 || Main.npc[k].type == 136)) {
 						float num4 = Math.Abs(Main.npc[k].Center.X - center.X) + Math.Abs(Main.npc[k].Center.Y - center.Y);
 						if (num4 < num3) {
@@ -56139,7 +_,7 @@
 
 		private void DropEoWLoot(bool fromCheckDead = true) {
 			bool flag = true;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (i != whoAmI && Main.npc[i].active && (Main.npc[i].type == 13 || Main.npc[i].type == 14 || Main.npc[i].type == 15)) {
 					flag = false;
 					break;
@@ -56447,7 +_,7 @@
 		}
 
 		public static void ResetKillCount() {
-			for (int i = 0; i < 670; i++) {
+			for (int i = 0; i < killCount.Length; i++) {
 				killCount[i] = 0;
 			}
 		}
@@ -56491,7 +_,7 @@
 		}
 
 		public void NPCLoot() {
-			if (Main.netMode == 1 || type >= 670)
+			if (Main.netMode == 1 || type >= NPCLoader.NPCCount)
 				return;
 
 			Player closestPlayer = Main.player[Player.FindClosest(position, width, height)];
@@ -56508,9 +_,13 @@
 			if ((type == 23 && Main.hardMode) || (SpawnedFromStatue && NPCID.Sets.NoEarlymodeLootWhenSpawnedFromStatue[type] && !Main.hardMode) || (SpawnedFromStatue && NPCID.Sets.StatueSpawnedDropRarity[type] != -1f && (Main.rand.NextFloat() >= NPCID.Sets.StatueSpawnedDropRarity[type] || !AnyInteractions())))
 				return;
 
+			if (!NPCLoader.PreKill(this))
+				return;
+
 			bool num = downedMechBoss1 && downedMechBoss2 && downedMechBoss3;
 			DoDeathEvents_BeforeLoot(closestPlayer);
 			NPCLoot_DropItems(closestPlayer);
+			NPCLoader.OnKill(this);
 			DoDeathEvents(closestPlayer);
 			if (!num && downedMechBoss1 && downedMechBoss2 && downedMechBoss3 && Main.hardMode) {
 				if (Main.netMode == 0)
@@ -56556,7 +_,7 @@
 			WoFKilledToday = false;
 		}
 
-		private void DoDeathEvents_DropBossPotionsAndHearts() {
+		private void DoDeathEvents_DropBossPotionsAndHearts(ref string typeName) {
 			int stack = Main.rand.Next(5, 16);
 			int num = 28;
 			if (type == 113)
@@ -56584,6 +_,7 @@
 			else if (type == 398)
 				num = 3544;
 
+			NPCLoader.BossLoot(this, ref typeName, ref num);
 			Item.NewItem(GetItemSource_Loot(), (int)position.X, (int)position.Y, width, height, num, stack);
 			int num2 = Main.rand.Next(5) + 5;
 			for (int i = 0; i < num2; i++) {
@@ -56601,7 +_,7 @@
 			}
 		}
 
-		private void DoDeathEvents_CelebrateBossDeath() {
+		private void DoDeathEvents_CelebrateBossDeath(string typeName) {
 			if (type == 125 || type == 126) {
 				if (Main.netMode == 0)
 					Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Plural", Language.GetTextValue("Enemies.TheTwins")), 175, 75);
@@ -56615,7 +_,7 @@
 					ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasBeenDefeated_Single", NetworkText.FromKey("Enemies.MoonLord")), new Color(175, 75, 255));
 			}
 			else if (Main.netMode == 0) {
-				Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Single", TypeName), 175, 75);
+				Main.NewText(Language.GetTextValue("Announcement.HasBeenDefeated_Single", typeName), 175, 75);
 			}
 			else if (Main.netMode == 2) {
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasBeenDefeated_Single", GetTypeNetName()), new Color(175, 75, 255));
@@ -57000,8 +_,10 @@
 			}
 
 			if (boss) {
+				string typeName = TypeName;
+
-				DoDeathEvents_DropBossPotionsAndHearts();
+				DoDeathEvents_DropBossPotionsAndHearts(ref typeName);
-				DoDeathEvents_CelebrateBossDeath();
+				DoDeathEvents_CelebrateBossDeath(typeName);
 				if (Main.netMode == 2)
 					NetMessage.SendData(7);
 			}
@@ -57238,7 +_,10 @@
 			}
 		}
 
+		// this is made internal because NPC.CheckCatchNPC now fulfills every use case
+		// that callin' this method manually could have for modders, and then some
+		// -thomas
-		public static void CatchNPC(int i, int who = -1) {
+		internal static void CatchNPC(int i, int who = -1) {
 			if (!Main.npc[i].active)
 				return;
 
@@ -57258,8 +_,14 @@
 					NetMessage.SendData(106, -1, -1, null, (int)position.X, position.Y);
 				}
 				else {
+					/*
 					new Item().SetDefaults(Main.npc[i].catchItem);
 					Item.NewItem(GetSpawnSource_NPCCatch(who), (int)Main.player[who].Center.X, (int)Main.player[who].Center.Y, 0, 0, Main.npc[i].catchItem, 1, noBroadcast: false, 0, noGrabDelay: true);
+					*/
+					int itemWhoAmI = Item.NewItem(GetSpawnSource_NPCCatch(who, Main.npc[i]), (int)Main.player[who].Center.X, (int)Main.player[who].Center.Y, 0, 0, Main.npc[i].catchItem, 1, true, 0, true, false);
+					
+					NetMessage.SendData(MessageID.SyncItem, -1, -1, null, itemWhoAmI, 1f); // NewItem above changed to noBroadcast, number2 is 1 for noGrabDelay effect.
+					
 					Main.npc[i].active = false;
 					NetMessage.SendData(23, -1, -1, null, i);
 				}
@@ -57293,42 +_,42 @@
 				return;
 
 			if (type == 13 || type == 14 || type == 15) {
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					if (i != whoAmI && Main.npc[i].active && (Main.npc[i].type == 13 || Main.npc[i].type == 14 || Main.npc[i].type == 15))
 						Main.npc[i].ApplyInteraction(player);
 				}
 			}
 
 			if (type == 134 || type == 135 || type == 136) {
-				for (int j = 0; j < 200; j++) {
+				for (int j = 0; j < Main.maxNPCs; j++) {
 					if (j != whoAmI && Main.npc[j].active && (Main.npc[j].type == 134 || Main.npc[j].type == 135 || Main.npc[j].type == 136))
 						Main.npc[j].ApplyInteraction(player);
 				}
 			}
 
 			if (type == 35 || type == 36) {
-				for (int k = 0; k < 200; k++) {
+				for (int k = 0; k < Main.maxNPCs; k++) {
 					if (k != whoAmI && Main.npc[k].active && (Main.npc[k].type == 35 || Main.npc[k].type == 36))
 						Main.npc[k].ApplyInteraction(player);
 				}
 			}
 
 			if (type == 113 || type == 114) {
-				for (int l = 0; l < 200; l++) {
+				for (int l = 0; l < Main.maxNPCs; l++) {
 					if (l != whoAmI && Main.npc[l].active && (Main.npc[l].type == 113 || Main.npc[l].type == 114))
 						Main.npc[l].ApplyInteraction(player);
 				}
 			}
 
 			if (type >= 127 && type <= 131) {
-				for (int m = 0; m < 200; m++) {
+				for (int m = 0; m < Main.maxNPCs; m++) {
 					if (m != whoAmI && Main.npc[m].active && Main.npc[m].type >= 127 && Main.npc[m].type <= 131)
 						Main.npc[m].ApplyInteraction(player);
 				}
 			}
 
 			if (type >= 245 && type <= 249) {
-				for (int n = 0; n < 200; n++) {
+				for (int n = 0; n < Main.maxNPCs; n++) {
 					if (n != whoAmI && Main.npc[n].active && Main.npc[n].type >= 245 && Main.npc[n].type <= 249)
 						Main.npc[n].ApplyInteraction(player);
 				}
@@ -57344,7 +_,7 @@
 				Main.npc[(int)ai[0]].ApplyInteraction(player);
 
 			if (type == 125 || type == 126) {
-				for (int num = 0; num < 200; num++) {
+				for (int num = 0; num < Main.maxNPCs; num++) {
 					if (num != whoAmI && Main.npc[num].active && (Main.npc[num].type == 125 || Main.npc[num].type == 126))
 						Main.npc[num].ApplyInteraction(player);
 				}
@@ -57374,7 +_,7 @@
 
 			int num2 = 0;
 			int num3 = 0;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active) {
 					num3++;
 					if (Main.npc[i].releaseOwner == who)
@@ -57396,11 +_,12 @@
 		}
 
 		public static void ReleaseNPC(int x, int y, int Type, int Style, int who) {
+			// Patch context.
 			if (Main.netMode == 1) {
 				NetMessage.SendData(71, -1, -1, null, x, y, Type, Style);
 			}
 			else {
-				if (Type < 0 || Type >= 670 || !Main.npcCatchable[Type] || !CanReleaseNPCs(who))
+				if (Type < 0 || Type >= NPCLoader.NPCCount || !Main.npcCatchable[Type] || !CanReleaseNPCs(who))
 					return;
 
 				switch (Type) {
@@ -57596,7 +_,7 @@
 			}
 
 			float num5 = 0f;
-			for (int j = 0; j < 200; j++) {
+			for (int j = 0; j < Main.maxNPCs; j++) {
 				if (Main.npc[j].active) {
 					switch (Main.npc[j].type) {
 						case 315:
@@ -57628,6 +_,7 @@
 			int num9;
 			int num10;
 			bool flag15;
+			NPCSpawnInfo spawnInfo = new NPCSpawnInfo();
 			while (true) {
 				if (num7 >= 255)
 					return;
@@ -57648,15 +_,17 @@
 						flag11 = false;
 						flag12 = false;
 						flag13 = false;
+						//patch file: flag14
 						flag14 = (downedPlantBoss && Main.hardMode);
 						isItAHappyWindyDay = Main.IsItAHappyWindyDay;
 						if (Main.player[num7].active && Main.invasionType > 0 && Main.invasionDelay == 0 && Main.invasionSize > 0 && (double)Main.player[num7].position.Y < Main.worldSurface * 16.0 + (double)sHeight) {
 							int num8 = 3000;
 							if ((double)Main.player[num7].position.X > Main.invasionX * 16.0 - (double)num8 && (double)Main.player[num7].position.X < Main.invasionX * 16.0 + (double)num8) {
+								//patch file: flag6
 								flag6 = true;
 							}
 							else if (Main.invasionX >= (double)(Main.maxTilesX / 2 - 5) && Main.invasionX <= (double)(Main.maxTilesX / 2 + 5)) {
-								for (int k = 0; k < 200; k++) {
+								for (int k = 0; k < Main.maxNPCs; k++) {
 									if (Main.npc[k].townNPC && Math.Abs(Main.player[num7].position.X - Main.npc[k].Center.X) < (float)num8) {
 										if (Main.rand.Next(3) != 0)
 											flag6 = true;
@@ -57668,14 +_,17 @@
 						}
 
 						if (Main.player[num7].ZoneTowerSolar || Main.player[num7].ZoneTowerNebula || Main.player[num7].ZoneTowerVortex || Main.player[num7].ZoneTowerStardust)
+							// Patch note: flag6 - Invasion.
 							flag6 = true;
 
 						num9 = (int)(Main.player[num7].position.X + (float)(Main.player[num7].width / 2)) / 16;
 						num10 = (int)(Main.player[num7].position.Y + (float)(Main.player[num7].height / 2)) / 16;
 						if (Main.wallHouse[Main.tile[num9, num10].wall])
+							//Patch note: flag5 - playerSafe
 							flag5 = true;
 
 						if (Main.tile[num9, num10].wall == 87)
+							//Patch note: flag4 - Lihzahrd
 							flag4 = true;
 
 						flag2 = false;
@@ -57947,12 +_,14 @@
 								}
 								else {
 									if (!Main.expertMode || Main.rand.Next(30) != 0)
+										// Patch note: flag12 - playerInTown??????????????? Pretty weird
 										flag12 = true;
 
 									maxSpawns = (int)((double)(float)maxSpawns * 0.6);
 								}
 							}
 						}
+						NPCLoader.EditSpawnRate(Main.player[num7], ref spawnRate, ref maxSpawns);
 
 						flag15 = false;
 						if (Main.player[num7].active && !Main.player[num7].dead && Main.player[num7].nearbyActiveNPCs < (float)maxSpawns && Main.rand.Next(spawnRate) == 0) {
@@ -57978,6 +_,7 @@
 								safeRangeY += (int)((double)(sHeight / 16) * 0.5 / (double)num12);
 							}
 
+							NPCLoader.EditSpawnRange(Main.player[num7], ref spawnRangeX, ref spawnRangeY, ref safeRangeX, ref safeRangeY);
 							int num13 = (int)(Main.player[num7].position.X / 16f) - spawnRangeX;
 							int num14 = (int)(Main.player[num7].position.X / 16f) + spawnRangeX;
 							int num15 = (int)(Main.player[num7].position.Y / 16f) - spawnRangeY;
@@ -58011,6 +_,7 @@
 										num2 = num22;
 										flag2 = true;
 										flag3 = true;
+										// Patch note: flag3 - Sky
 									}
 									else if (!flag6 && (double)num22 < Main.worldSurface * 0.44999998807907104 && !flag12 && Main.hardMode && Main.rand.Next(10) == 0) {
 										num3 = Main.tile[num21, num22].type;
@@ -58071,6 +_,7 @@
 										}
 
 										if (num >= num17 && num <= num18)
+											// Patch note: flag15 - safeRangeX
 											flag15 = true;
 									}
 								}
@@ -58097,17 +_,23 @@
 
 							if (Main.tile[num, num2 - 1].liquid > 0 && Main.tile[num, num2 - 2].liquid > 0 && !Main.tile[num, num2 - 1].lava()) {
 								if (Main.tile[num, num2 - 1].honey())
+									// Patch note: flag8 - Honey
 									flag8 = true;
 								else
+									// Patch note: flag7 - Water
 									flag7 = true;
 							}
 
 							int num29 = (int)Main.player[num7].Center.X / 16;
 							int num30 = (int)(Main.player[num7].Bottom.Y + 8f) / 16;
+							spawnInfo.PlayerFloorX = num29;
+							spawnInfo.PlayerFloorY = num30;
 							if (Main.tile[num, num2].type == 367) {
+								// Patch note: flag10 - marble
 								flag10 = true;
 							}
 							else if (Main.tile[num, num2].type == 368) {
+								// Patch note: flag9 - granite
 								flag9 = true;
 							}
 							else if (Main.tile[num29, num30].type == 367) {
@@ -58196,6 +_,7 @@
 						for (int num40 = num - num39; num40 < num + num39; num40++) {
 							for (int num41 = num2 - num39; num41 < num2 + num39; num41++) {
 								if (Main.tile[num40, num41].wall == 62)
+									// Patch note: flag11 - Spider wall
 									flag11 = true;
 							}
 						}
@@ -58216,6 +_,7 @@
 						for (int num45 = num - num44; num45 < num + num44; num45++) {
 							for (int num46 = num2 - num44; num46 < num2 + num44; num46++) {
 								if (WallID.Sets.Conversion.Sandstone[Main.tile[num45, num46].wall] || WallID.Sets.Conversion.HardenedSand[Main.tile[num45, num46].wall])
+									// Patch note: flag13 - Desert cave
 									flag13 = true;
 							}
 						}
@@ -58237,9 +_,35 @@
 
 			bool flag18 = (float)new Point(num9 - num, num10 - num2).X * Main.windSpeedTarget > 0f;
 			spawnTileType = SpawnNPC_TryFindingProperGroundTileType(spawnTileType, num, num2);
-			int newNPC = 200;
+
+			spawnInfo.SpawnTileX = num;
+			spawnInfo.SpawnTileY = num2;
+			spawnInfo.SpawnTileType = num3;
+			spawnInfo.Player = Main.player[num7];
+			spawnInfo.Sky = flag3;
+			spawnInfo.Lihzahrd = flag4;
+			spawnInfo.PlayerSafe = flag5;
+			spawnInfo.Invasion = flag6;
+			spawnInfo.Water = flag7;
+			spawnInfo.Granite = flag9;
+			spawnInfo.Marble = flag10;
+			spawnInfo.SpiderCave = flag11;
+			spawnInfo.PlayerInTown = flag12;
+			spawnInfo.DesertCave = flag13;
+			spawnInfo.PlanteraDefeated = flag14;
+			spawnInfo.SafeRangeX = flag15;
+
+			int newNPC = Main.maxNPCs;
 			int cattailX;
 			int cattailY;
+			int? spawnChoice = NPCLoader.ChooseSpawn(spawnInfo);
+			if (!spawnChoice.HasValue)
+				return;
+
+			int spawn = spawnChoice.Value;
+			if (spawn != 0)
+				goto endVanillaSpawn;
+
 			if (Main.player[num7].ZoneTowerNebula) {
 				bool flag19 = true;
 				int num50 = 0;
@@ -60370,13 +_,18 @@
 				}
 			}
 
+			endVanillaSpawn:
+
+			if (spawn != 0)
+				newNPC = NPCLoader.SpawnNPC(spawn, num, num2);
+
 			if (Main.npc[newNPC].type == 1 && Main.player[num7].RollLuck(180) == 0)
 				Main.npc[newNPC].SetDefaults(-4);
 
 			if (Main.tenthAnniversaryWorld && Main.npc[newNPC].type == 1 && Main.player[num7].RollLuck(180) == 0)
 				Main.npc[newNPC].SetDefaults(667);
 
-			if (Main.netMode == 2 && newNPC < 200)
+			if (Main.netMode == 2 && newNPC < Main.maxNPCs)
 				NetMessage.SendData(23, -1, -1, null, newNPC);
 		}
 
@@ -60509,7 +_,7 @@
 					flag |= Main.CurrentFrameFlags.AnyActiveBossNPC;
 				}
 				else {
-					for (int i = 0; i < 200; i++) {
+					for (int i = 0; i < Main.maxNPCs; i++) {
 						if (!Main.npc[i].active || (!Main.npc[i].boss && !NPCID.Sets.DangerThatPreventsOtherDangers[Main.npc[i].type]))
 							continue;
 
@@ -60619,14 +_,14 @@
 			Vector2 vector = Vector2.Zero;
 			int num = 0;
 			int num2 = 0;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == 35) {
 					flag = false;
 					break;
 				}
 			}
 
-			for (int j = 0; j < 200; j++) {
+			for (int j = 0; j < Main.maxNPCs; j++) {
 				if (!Main.npc[j].active)
 					continue;
 
@@ -60881,15 +_,15 @@
 		public static IEntitySource GetBossSpawnSource(int targetPlayerIndex) => new EntitySource_BossSpawn(Main.player[targetPlayerIndex]);
 
 		public static void SpawnBoss(int spawnPositionX, int spawnPositionY, int Type, int targetPlayerIndex) {
-			int num = 200;
+			int num = Main.maxNPCs;
 			num = NewNPC(GetBossSpawnSource(targetPlayerIndex), spawnPositionX, spawnPositionY, Type, 1);
-			if (num == 200)
+			if (num == Main.maxNPCs)
 				return;
 
 			Main.npc[num].target = targetPlayerIndex;
 			Main.npc[num].timeLeft *= 20;
 			string typeName = Main.npc[num].TypeName;
-			if (Main.netMode == 2 && num < 200)
+			if (Main.netMode == 2 && num < Main.maxNPCs)
 				NetMessage.SendData(23, -1, -1, null, num);
 
 			if (Type == 134 || Type == 127 || Type == 126 || Type == 125)
@@ -60918,6 +_,20 @@
 				ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasAwoken", Main.npc[num].GetTypeNetName()), new Color(175, 75, 255));
 		}
 
+		/// <summary>
+		/// Spawns an NPC into the game world with the given type. This method should not be called on multiplayer clients. The X and Y parameters dictate the centered spawn position. ai0, ai1, ai2, and ai3 will initialize the NPC.ai[] array with the supplied values. This can be used to pass in information to the NPC. The NPC AI code will have to be written to utilize those values. Target can be set to a Player.whoAmI to have the NPC targetting a specific Player immediately on spawn. Start can be used to ensure that an NPC spawns in a slot after an existing NPC. This can be used to ensure that the spawned NPC draws behind an existing NPC. This is useful for bosses that spawn minions. The return value is the index of the spawned NPC within the <see cref="Main.npc"/> array. 
+		/// </summary>
+		/// <param name="source"></param>
+		/// <param name="X"></param>
+		/// <param name="Y"></param>
+		/// <param name="Type">Either an <see cref="NPCID"/> entry or <see cref="ModContent.NPCType{T}"/>, for example <see cref="NPCID.BabySlime"/> or ModContent.NPCType&lt;MyModNPC&gt;()</param>
+		/// <param name="Start"></param>
+		/// <param name="ai0"></param>
+		/// <param name="ai1"></param>
+		/// <param name="ai2"></param>
+		/// <param name="ai3"></param>
+		/// <param name="Target"></param>
+		/// <returns></returns>
 		public static int NewNPC(IEntitySource source, int X, int Y, int Type, int Start = 0, float ai0 = 0f, float ai1 = 0f, float ai2 = 0f, float ai3 = 0f, int Target = 255) {
 			if (Main.getGoodWorld) {
 				if (Type == 46)
@@ -60928,8 +_,10 @@
 			}
 
 			int num = -1;
-			if (Type == 222 || Type == 245) {
-				for (int num2 = 199; num2 >= 0; num2--) {
+
+			//if (Type == 222 || Type == 245) {
+			if (Type >= 0 && NPCID.Sets.SpawnFromLastEmptySlot[Type]) {
+				for (int num2 = (Main.maxNPCs - 1); num2 >= 0; num2--) {
 					if (!Main.npc[num2].active) {
 						num = num2;
 						break;
@@ -60937,7 +_,7 @@
 				}
 			}
 			else {
-				for (int i = Start; i < 200; i++) {
+				for (int i = Start; i < Main.maxNPCs; i++) {
 					if (!Main.npc[i].active) {
 						num = i;
 						break;
@@ -60967,16 +_,18 @@
 						ChatHelper.BroadcastChatMessage(NetworkText.FromKey("Announcement.HasAwoken", Main.npc[num].GetTypeNetName()), new Color(175, 75, 255));
 				}
 
+				NPCLoader.OnSpawn(Main.npc[num], source);
+
 				return num;
 			}
 
-			return 200;
+			return Main.maxNPCs;
 		}
 
 		private static void GiveTownUniqueDataToNPCsThatNeedIt(int Type, int nextNPC) {
-			if (TypeToDefaultHeadIndex(Type) != -1 || Type == 453) {
-				Main.npc[nextNPC].GivenName = getNewNPCName(Type);
-				if (TownNPCProfiles.Instance.GetProfile(Type, out ITownNPCProfile profile)) {
+			if (TypeToDefaultHeadIndex(Type) != -1 || (Type >= 0 && NPCID.Sets.SpawnsWithCustomName[Type])) {
+				Main.npc[nextNPC].GivenName = Main.npc[nextNPC].getNewNPCName();
+				if (TownNPCProfiles.Instance.GetProfile(Main.npc[nextNPC], out ITownNPCProfile profile)) {
 					Main.npc[nextNPC].townNpcVariationIndex = profile.RollVariation();
 					Main.npc[nextNPC].GivenName = profile.GetNameForVariant(Main.npc[nextNPC]);
 				}
@@ -61171,12 +_,14 @@
 			if (num2 < 0)
 				num2 = 0;
 
+			if (NPCLoader.StrikeNPC(this, ref num, num2, ref knockBack, hitDirection, ref crit)) {
-			num = Main.CalculateDamageNPCsTake((int)num, num2);
+				num = Main.CalculateDamageNPCsTake((int)num, num2);
-			if (crit)
+				if (crit)
-				num *= 2.0;
+					num *= 2.0;
 
-			if (takenDamageMultiplier > 1f)
+				if (takenDamageMultiplier > 1f)
-				num *= (double)takenDamageMultiplier;
+					num *= takenDamageMultiplier;
+			}
 
 			if ((takenDamageMultiplier > 1f || Damage != 9999) && lifeMax > 1) {
 				if (friendly) {
@@ -61360,7 +_,7 @@
 				}
 
 				if ((type == 113 || type == 114) && life <= 0) {
-					for (int i = 0; i < 200; i++) {
+					for (int i = 0; i < Main.maxNPCs; i++) {
 						if (Main.npc[i].active && (Main.npc[i].type == 113 || Main.npc[i].type == 114))
 							Main.npc[i].HitEffect(hitDirection, num);
 					}
@@ -61453,7 +_,20 @@
 			}
 		}
 
+		public void HitEffect(int hitDirection = 0, double dmg = 10.0)
+			=> NPCLoader.HitEffect(this, hitDirection, dmg);
+
-		public void HitEffect(int hitDirection = 0, double dmg = 10.0) {
+		public void VanillaHitEffect(int hitDirection = 0, double dmg = 10.0) {
+			var usedSource = new EntitySource_HitEffect(this);
+
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			VanillaHitEffect_Inner(hitDirection, dmg);
+
+			IEntitySource.PopFallback();
+		}
+
+		private void VanillaHitEffect_Inner(int hitDirection, double dmg) {
 			if (!active)
 				return;
 
@@ -61538,7 +_,7 @@
 				}
 
 				if (Main.netMode != 1) {
-					for (int j = 0; j < 200; j++) {
+					for (int j = 0; j < Main.maxNPCs; j++) {
 						NPC nPC = Main.npc[j];
 						if (nPC.active && !nPC.buffImmune[189] && Distance(nPC.Center) < 100f && !nPC.dontTakeDamage && nPC.lifeMax > 5 && !nPC.friendly && !nPC.townNPC)
 							nPC.AddBuff(189, 300);
@@ -64083,7 +_,7 @@
 							Main.npc[num317].velocity.X += (float)Main.rand.Next(-20, 20) * 0.1f + (float)(num316 * direction) * 0.3f;
 							Main.npc[num317].velocity.Y -= (float)Main.rand.Next(0, 10) * 0.1f + (float)num316;
 							Main.npc[num317].ai[0] = -1000 * Main.rand.Next(3);
-							if (Main.netMode == 2 && num317 < 200)
+							if (Main.netMode == 2 && num317 < Main.maxNPCs)
 								NetMessage.SendData(23, -1, -1, null, num317);
 						}
 					}
@@ -64618,7 +_,7 @@
 							Main.npc[num396].velocity.X = base.velocity.X;
 							Main.npc[num396].velocity.Y = base.velocity.Y;
 							Gore.NewGore(base.position, base.velocity, 94, scale);
-							if (Main.netMode == 2 && num396 < 200)
+							if (Main.netMode == 2 && num396 < Main.maxNPCs)
 								NetMessage.SendData(23, -1, -1, null, num396);
 						}
 						else if (scale >= 1f) {
@@ -64631,7 +_,7 @@
 								Main.npc[num399].velocity.X += (float)Main.rand.Next(-10, 10) * 0.1f + (float)(num398 * direction) * 0.3f;
 								Main.npc[num399].velocity.Y -= (float)Main.rand.Next(0, 10) * 0.1f + (float)num398;
 								Main.npc[num399].ai[1] = num398;
-								if (Main.netMode == 2 && num399 < 200)
+								if (Main.netMode == 2 && num399 < Main.maxNPCs)
 									NetMessage.SendData(23, -1, -1, null, num399);
 							}
 						}
@@ -64767,7 +_,7 @@
 					Main.npc[num423].velocity.Y = (float)Main.rand.Next(-30, 1) * 0.1f;
 					Main.npc[num423].ai[0] = -1000 * Main.rand.Next(3);
 					Main.npc[num423].ai[1] = 0f;
-					if (Main.netMode == 2 && num423 < 200)
+					if (Main.netMode == 2 && num423 < Main.maxNPCs)
 						NetMessage.SendData(23, -1, -1, null, num423);
 				}
 			}
@@ -67940,7 +_,7 @@
 				if (type == 135 && life > 0 && Main.netMode != 1 && ai[2] == 0f && Main.rand.Next(25) == 0) {
 					ai[2] = 1f;
 					int num763 = NewNPC(GetSpawnSource_NPCHurt(), (int)(base.position.X + (float)(width / 2)), (int)(base.position.Y + (float)height), 139);
-					if (Main.netMode == 2 && num763 < 200)
+					if (Main.netMode == 2 && num763 < Main.maxNPCs)
 						NetMessage.SendData(23, -1, -1, null, num763);
 
 					netUpdate = true;
@@ -68487,7 +_,7 @@
 
 		public static int CountNPCS(int Type) {
 			int num = 0;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == Type)
 					num++;
 			}
@@ -68496,7 +_,7 @@
 		}
 
 		public static bool AnyHelpfulFairies() {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && (Main.npc[i].type == 583 || Main.npc[i].type == 584 || Main.npc[i].type == 585) && Main.npc[i].ai[2] > 1f)
 					return true;
 			}
@@ -68505,7 +_,7 @@
 		}
 
 		public static bool AnyNPCs(int Type) {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == Type)
 					return true;
 			}
@@ -68514,7 +_,7 @@
 		}
 
 		public static int FindFirstNPC(int Type) {
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].type == Type)
 					return i;
 			}
@@ -68524,7 +_,7 @@
 
 		public static bool NearSpikeBall(int x, int y) {
 			Rectangle rectangle = new Rectangle(x * 16 - 300, y * 16 - 300, 600, 600);
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active && Main.npc[i].aiStyle == 20) {
 					Rectangle rectangle2 = new Rectangle((int)Main.npc[i].ai[1], (int)Main.npc[i].ai[2], 20, 20);
 					if (rectangle.Intersects(rectangle2))
@@ -68561,6 +_,8 @@
 			int num = -1;
 			for (int i = 0; i < 5; i++) {
 				if (buffType[i] == type) {
+					if (BuffLoader.ReApply(type, this, time, i))
+						return;
 					if (buffTime[i] < time)
 						buffTime[i] = time;
 
@@ -68596,7 +_,7 @@
 		}
 
 		public void RequestBuffRemoval(int buffTypeToRemove) {
-			if (buffTypeToRemove < 0 || buffTypeToRemove >= 338 || !BuffID.Sets.CanBeRemovedByNetMessage[buffTypeToRemove])
+			if (buffTypeToRemove < 0 || buffTypeToRemove >= BuffLoader.BuffCount || !BuffID.Sets.CanBeRemovedByNetMessage[buffTypeToRemove])
 				return;
 
 			int num = FindBuffIndex(buffTypeToRemove);
@@ -68768,16 +_,25 @@
 
 		public static void ResetNetOffsets() {
 			offSetDelayTime = 180;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				Main.npc[i].netOffset *= 0f;
 			}
 		}
 
 		public void UpdateNPC(int i) {
 			whoAmI = i;
+
 			if (!active)
 				return;
 
+			IEntitySource.PushFallback(thisEntitySourceCache);
+
+			UpdateNPC_Inner(i);
+
+			IEntitySource.PopFallback();
+		}
+
+		private void UpdateNPC_Inner(int i) {
 			if (offSetDelayTime > 0) {
 				netOffset *= 0f;
 			}
@@ -68791,7 +_,7 @@
 				if (NPCID.Sets.NoMultiplayerSmoothingByType[type]) {
 					netOffset *= 0f;
 				}
-				else if (NPCID.Sets.NoMultiplayerSmoothingByAI[aiStyle]) {
+				else if (aiStyle >= 0 && aiStyle < NPCLoader.NPCCount && NPCID.Sets.NoMultiplayerSmoothingByAI[aiStyle]) {
 					netOffset *= 0f;
 				}
 				else {
@@ -68837,6 +_,7 @@
 				bool flag = false;
 				int num4 = (int)(position.X + (float)(width / 2)) / 16;
 				int num5 = (int)(position.Y + (float)(height / 2)) / 16;
+				/*
 				try {
 					if (num4 >= 4 && num4 <= Main.maxTilesX - 4 && num5 >= 4 && num5 <= Main.maxTilesY - 4) {
 						if (Main.tile[num4, num5] == null)
@@ -68854,12 +_,14 @@
 				catch {
 					flag = true;
 				}
+				*/
 
-				if (flag)
+				if (!Main.sectionManager.TilesLoaded(num4 - 3, num5 - 3, num4 + 3, num5 + 3))
 					return;
 			}
 
 			UpdateNPC_BuffFlagsReset();
+			NPCLoader.ResetEffects(this);
 			UpdateNPC_BuffSetFlags();
 			UpdateNPC_SoulDrainDebuff();
 			UpdateNPC_BuffClearExpiredBuffs();
@@ -69075,6 +_,8 @@
 			}
 		}
 
+		// Original vanilla methods:
+		/*
 		public static IEntitySource GetSpawnSource_NPCRelease(int whoReleasedIt) => new EntitySource_Parent(Main.player[whoReleasedIt]);
 		public static IEntitySource GetSpawnSource_NPCCatch(int whoCatchedIt) => new EntitySource_Parent(Main.player[whoCatchedIt]);
 		public IEntitySource GetSpawnSource_NPCHurt() => new EntitySource_Parent(this);
@@ -69084,6 +_,23 @@
 		public static IEntitySource GetSpawnSourceForTownSpawn() => new EntitySource_SpawnNPC();
 		public IEntitySource GetSpawnSourceForNPCFromNPCAI() => new EntitySource_Parent(this);
 		public IEntitySource GetItemSource_Loot() => new EntitySource_Loot(this);
+		*/
+
+		// Internal redirects:
+		internal static IEntitySource GetSpawnSource_NPCRelease(int whoReleasedIt) => Main.player[whoReleasedIt].GetSource_ReleaseEntity();
+		internal static IEntitySource GetSpawnSource_NPCCatch(int whoCaughtIt, Entity caughtEntity) => Main.player[whoCaughtIt].GetSource_CatchEntity(caughtEntity);
+		internal static IEntitySource GetSpawnSourceForNaturalSpawn() => GetSource_NaturalSpawn();
+		internal static IEntitySource GetSpawnSourceForTownSpawn() => GetSource_TownSpawn();
+		
+		internal IEntitySource GetSpawnSource_NPCHurt() => new EntitySource_Parent(this);
+		internal IEntitySource GetSpawnSource_ForProjectile() => GetSource_FromAI();
+		internal IEntitySource GetSpawnSourceForProjectileNPC() => GetSource_FromAI();
+		internal IEntitySource GetSpawnSourceForNPCFromNPCAI() => GetSource_FromAI();
+		internal IEntitySource GetItemSource_Loot() => GetSource_Loot();
+
+		// Public API methods can be found in:
+		//   Entity.TML.Sources.cs;
+		//   NPC.TML.Sources.cs (if exists);
 
 		private void UpdateNPC_UpdateTrails() {
 			int num = NPCID.Sets.TrailingMode[type];
@@ -69822,6 +_,7 @@
 					num = 5;
 			}
 
+			NPCLoader.UpdateLifeRegen(this, ref num);
 			if (lifeRegen <= -240 && num < 2)
 				num = 2;
 
@@ -70013,6 +_,7 @@
 
 					if (buffType[i] == 324)
 						onFrostBurn2 = true;
+					BuffLoader.Update(buffType[i], this, ref i); // todo, move?
 				}
 			}
 		}
@@ -70206,12 +_,17 @@
 				return;
 
 			Rectangle hitbox = base.Hitbox;
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				NPC nPC = Main.npc[i];
 				if (acceptableNPCIDs[nPC.type] && nPC.active && !nPC.friendly && nPC.damage > 0) {
 					Rectangle npcRect = nPC.Hitbox;
 					GetMeleeCollisionData(hitbox, i, ref specialHitSetter, ref damageMultiplier, ref npcRect);
+					bool? modCanHit = NPCLoader.CanHitNPC(Main.npc[i], this);
+					if (modCanHit.HasValue && !modCanHit.Value)
+						continue;
+
+					// TODO: NPCLoader.CanHitNPC should return a plain bool. The only use of "override true" below is to force the skeleton merchant to be hit by skeletons
-					if (hitbox.Intersects(npcRect) && (type != 453 || !NPCID.Sets.Skeletons[nPC.type]) && nPC.type != 624)
+					if (hitbox.Intersects(npcRect) && ((modCanHit == true) || type != 453 || !NPCID.Sets.Skeletons[nPC.type])&& nPC.type != 624)
 						BeHurtByOtherNPC(i, nPC);
 				}
 			}
@@ -70223,14 +_,17 @@
 				num = 20;
 
 			int num2 = Main.DamageVar(thatNPC.damage);
-			int num3 = 6;
+			float num3 = 6;
 			int num4 = (!(thatNPC.Center.X > base.Center.X)) ? 1 : (-1);
-			double num5 = StrikeNPCNoInteraction(num2, num3, num4);
+			bool crit = false;
+			NPCLoader.ModifyHitNPC(thatNPC, this, ref num2, ref num3, ref crit);
+			double num5 = StrikeNPCNoInteraction(num2, num3, num4, crit, false, false);
 			if (Main.netMode != 0)
 				NetMessage.SendData(28, -1, -1, null, whoAmI, num2, num3, num4);
 
 			netUpdate = true;
 			immune[255] = num;
+			NPCLoader.OnHitNPC(thatNPC, this, (int)num5, num3, crit);
 			if (dryadWard) {
 				num2 = (int)num5 / 3;
 				num3 = 6;
@@ -70517,7 +_,7 @@
 				cHeight = 40;
 
 			if (type == 391) {
-				for (int i = 0; i < 200; i++) {
+				for (int i = 0; i < Main.maxNPCs; i++) {
 					if (Main.npc[i].active && Main.npc[i].type == 390 && Main.npc[i].ai[0] == (float)whoAmI) {
 						cHeight = 62;
 						break;
@@ -70526,7 +_,7 @@
 			}
 
 			if (type == 415) {
-				for (int j = 0; j < 200; j++) {
+				for (int j = 0; j < Main.maxNPCs; j++) {
 					if (Main.npc[j].active && Main.npc[j].type == 416 && Main.npc[j].ai[0] == (float)whoAmI) {
 						cHeight = 62;
 						break;
@@ -70586,6 +_,10 @@
 		}
 
 		private bool Collision_DecideFallThroughPlatforms() {
+			bool? modResult = NPCLoader.CanFallThroughPlatforms(this);
+			if (modResult.HasValue)
+				return modResult.Value;
+
 			bool result = false;
 			if (type == 2 || type == -43 || type == 190 || type == 191 || type == 192 || type == 193 || type == 194 || type == 317 || type == 318 || type == 133)
 				result = true;
@@ -70871,6 +_,10 @@
 			if (IsABestiaryIconDummy)
 				newColor = Color.White;
 
+			Color? modColor = NPCLoader.GetAlpha(this, newColor);
+			if (modColor.HasValue)
+				return modColor.Value;
+
 			float num = (float)(255 - alpha) / 255f;
 			int num2 = (int)((float)(int)newColor.R * num);
 			int num3 = (int)((float)(int)newColor.G * num);
@@ -71117,7 +_,7 @@
 			bool flag16 = false;
 			bool flag17 = false;
 			object obj = Lang.CreateDialogSubstitutionObject(this);
-			for (int i = 0; i < 200; i++) {
+			for (int i = 0; i < Main.maxNPCs; i++) {
 				if (Main.npc[i].active) {
 					if (Main.npc[i].type == 17)
 						flag = true;
@@ -72350,6 +_,7 @@
 				result = ((!HasSpecialEventText("Bunny", out specialEventText)) ? Lang.BunnyChat(this) : specialEventText);
 			}
 
+			NPCLoader.GetChat(this, ref result);
 			return result;
 		}
 
